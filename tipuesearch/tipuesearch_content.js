var tipuesearch = {"pages":[{"title":" M_list ","text":"M_list M_list(3f) - maintain a sorted intrinsic type array in Fortran Description As shown in the examples the M_list(3f) module contains simple routines\n   to add, replace  and delete values from an automatically sorted array,\n   which allows for creating simple dictionaries. The advantage of this routine over more conventional methods is\n   that the dictionary components are simple arrays which can be easily\n   accessed with standard routines. Each time an entry is added or deleted the array is re-allocated.\n   Because of the expense of reallocating the data these routines are best\n   suited for maintaining small lists that do not change size frequently. For more demanding needs, see linked-list methods for maintaining generic\n   dictionaries; several examples of which are available on the Fortran Wiki. Building the Module Using make(1) Just download the github repository, enter the src/ directory and run make(1): git clone https : // github . com / urbanjost / M_list . git cd M_list / src # change Makefile if not using one of the listed compilers # for gfortran make clean make F90 = gfortran gfortran # for ifort make clean make F90 = ifort ifort # for nvfortran make clean make F90 = nvfortran nvfortran # optionally make run # run all the demo programs from the man - pages make help # see other developer options This will compile the M_list(3f) module. Build and Test with fpm Alternatively, download the github repository and build it with \nfpm ( as described at Fortran Package Manager ) git clone https://github.com/urbanjost/M_list.git cd M_list\n     fpm test # run unit tests # optionally run the example programs from the man-pages in the example/ directory fpm run --example \"*\" or just list it as a dependency in your fpm.toml project file. [dependencies] M_list = { git = \"https://github.com/urbanjost/M_list.git\" , tag = \"v1.0.1\" } (registered at the fpm(1) registry ) Documentation User A single page that uses javascript to combine all the HTML descriptions\n   of the man-pages is at BOOK_M_list . An index to HTML versions\n   of the man-pages man-pages in manpages.zip manpages.tgz Developer ford(1) output . github action status Demo Programs There are demo programs extracted from the man pages in the example/ directory Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"dictionary – M_list ","text":"type, public :: dictionary Contents Variables count key value Type-Bound Procedures clr del get ifdef set Source Code dictionary Components Type Visibility Attributes Name Initial integer, public, allocatable :: count (:) character(len=:), public, allocatable :: key (:) character(len=:), public, allocatable :: value (:) Type-Bound Procedures procedure, public :: clr => dict_clear private  subroutine dict_clear(self) NAME clr(3f) - [M_list::dictionary::OOPS] clear basic dictionary\n(LICENSE:PD) SYNOPSIS type(dictionary) :: dict call dict%clr() DESCRIPTION clear a basic dictionary. OPTIONS DICT   the dictionary. EXAMPLES create and clear a basic dictionary program demo_clr use M_list , only : dictionary implicit none type ( dictionary ) :: caps integer :: i ! create a character string dictionary call caps % set ( ' A ' , ' aye ' ) call caps % set ( ' B ' , ' bee ' ) call caps % set ( ' C ' , ' see ' ) call caps % set ( ' D ' , ' dee ' ) ! show current dictionary write ( * , ' (\"DICTIONARY BEFORE CLEARED\") ' ) write ( * , 101 )( trim ( caps % key ( i )) , trim ( caps % value ( i )) , i = 1 , size ( caps % key )) call caps % clr () write ( * , ' (\"DICTIONARY AFTER CLEARED\") ' ) ! show current dictionary write ( * , 101 )( trim ( caps % key ( i )) , trim ( caps % value ( i )) , i = 1 , size ( caps % key )) 101 format ( 1 x , * ( a , \" =' \" , a , \" ' \" ,:, \" , \" )) end program demo_clr Results > DICTIONARY BEFORE CLEARED\n   >  D='dee',C='see',B='bee',A='aye'\n   > DICTIONARY AFTER CLEARED AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: self procedure, public :: del => dict_delete private  subroutine dict_delete(self, key) NAME del(3f) - [M_list::dictionary::OOPS] delete entry by key name from\n          a basic dictionary\n(LICENSE:PD) SYNOPSIS type(dictionary) :: dict character(len=*),intent(in) :: key\n\ndict%del(key) DESCRIPTION Delete an entry from a basic dictionary if it is present . OPTIONS DICT   the dictionary.\nKEY    the key name to find and delete from the dictionary. EXAMPLES Delete an entry from a dictionary by key name. program demo_del use M_list , only : dictionary implicit none type ( dictionary ) :: caps integer :: i ! create a character string dictionary call caps % set ( ' A ' , ' aye ' ) call caps % set ( ' B ' , ' bee ' ) call caps % set ( ' C ' , ' see ' ) call caps % set ( ' D ' , ' dee ' ) ! show current dictionary write ( * , 101 )( trim ( caps % key ( i )) , trim ( caps % value ( i )) , i = 1 , size ( caps % key )) ! delete dictionary entries call caps % del ( ' A ' ) call caps % del ( ' C ' ) call caps % del ( ' z ' ) ! a noop as there is no key of ' z ' ! show current dictionary write ( * , 101 )( trim ( caps % key ( i )) , trim ( caps % value ( i )) , i = 1 , size ( caps % key )) 101 format ( 1 x , * ( a , \" =' \" , a , \" ' \" ,:, \" , \" )) end program demo_del Results > D='dee',C='see',B='bee',A='aye'\n    > D='dee',B='bee' AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: self character(len=*), intent(in) :: key procedure, public :: get => dict_get private  function dict_get(self, key) result(value) NAME get(3f) - [M_list::dictionary::OOPS] get value of key-value pair in\n          a dictionary given key\n(LICENSE:PD) SYNOPSIS type(dictionary) :: dict character(len=*),intent(in) :: key\ncharacter(len=*),intent(in) :: VALUE\n\nvalue=dict%get(key) DESCRIPTION get a value given a key from a key - value dictionary If key is not found in dictionary , return a blank OPTIONS DICT     is the dictionary.\nKEY      key name\nVALUE    value associated with key EXAMPLES Sample program: program demo_get use M_list , only : dictionary implicit none type ( dictionary ) :: table character ( len = : ) , allocatable :: val integer :: i call table % set ( ' A ' , ' value for A ' ) call table % set ( ' B ' , ' value for B ' ) call table % set ( ' C ' , ' value for C ' ) call table % set ( ' D ' , ' value for D ' ) call table % set ( ' E ' , ' value for E ' ) call table % set ( ' F ' , ' value for F ' ) call table % set ( ' G ' , ' value for G ' ) write ( * , * ) ' A= ' , table % get ( ' A ' ) write ( * , * ) ' B= ' , table % get ( ' B ' ) write ( * , * ) ' C= ' , table % get ( ' C ' ) write ( * , * ) ' D= ' , table % get ( ' D ' ) write ( * , * ) ' E= ' , table % get ( ' E ' ) write ( * , * ) ' F= ' , table % get ( ' F ' ) write ( * , * ) ' G= ' , table % get ( ' G ' ) write ( * , * ) ' H= ' , table % get ( ' H ' ) end program demo_get Results > A = value for A > B = value for B > C = value for C > D = value for D > E = value for E > F = value for F > G = value for G > H = AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: self character(len=*), intent(in) :: key Return Value character(len=:), allocatable procedure, public :: ifdef => dict_ifdef private  function dict_ifdef(self, key) result(value) NAME ifdef ( 3 f ) - [ M_list :: dictionary :: OOPS ] return whether name is present in dictionary or not ( LICENSE : PD ) SYNOPSIS type(dictionary) :: dict character(len=*),intent(in) :: key\nlogical :: value\n\nvalue=dict%ifdef(key) DESCRIPTION determine if name is already defined in dictionary or not OPTIONS DICT     is the dictionary.\nKEY      key name RETURNS VALUE . FALSE . if name not defined , . TRUE if name is defined . EXAMPLES Sample program: program demo_ifdef use M_list , only : dictionary implicit none type ( dictionary ) :: table character ( len = : ) , allocatable :: val integer :: i call table % set ( ' A ' , ' value for A ' ) call table % set ( ' B ' , ' value for B ' ) call table % set ( ' C ' , ' value for C ' ) call table % set ( ' D ' , ' value for D ' ) call table % set ( ' E ' , ' value for E ' ) call table % set ( ' F ' , ' value for F ' ) call table % set ( ' G ' , ' value for G ' ) call table % del ( ' F ' ) call table % del ( ' D ' ) write ( * , * ) ' A= ' , table % ifdef ( ' A ' ) write ( * , * ) ' B= ' , table % ifdef ( ' B ' ) write ( * , * ) ' C= ' , table % ifdef ( ' C ' ) write ( * , * ) ' D= ' , table % ifdef ( ' D ' ) write ( * , * ) ' E= ' , table % ifdef ( ' E ' ) write ( * , * ) ' F= ' , table % ifdef ( ' F ' ) write ( * , * ) ' G= ' , table % ifdef ( ' G ' ) write ( * , * ) ' H= ' , table % ifdef ( ' H ' ) end program demo_ifdef Results: > A= T\n > B= T\n > C= T\n > D= F\n > E= T\n > F= F\n > G= T\n > H= F AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: self character(len=*), intent(in) :: key Return Value logical procedure, public :: set => dict_add private  subroutine dict_add(self, key, value) NAME set(3f) - [M_list::dictionary::OOPS] add or replace a key-value pair\n          in a dictionary\n(LICENSE:PD) SYNOPSIS type(dictionary) :: dict character(len=*),intent(in) :: key\ncharacter(len=*),intent(in) :: VALUE\n\ncall dict%rep(key,value) DESCRIPTION Add or replace a key-value pair in a dictionary. OPTIONS DICT     is the dictionary.\nkey      key name\nVALUE    value associated with key EXAMPLES Add or replace a key and value pair in a dictionary program demo_set use M_list , only : dictionary implicit none type ( dictionary ) :: dict integer :: i call dict % set ( ' A ' , ' b ' ) call dict % set ( ' B ' , ' &#94; ' ) call dict % set ( ' C ' , ' ' ) call dict % set ( ' D ' , ' c ' ) call dict % set ( ' E ' , ' ZZ ' ) call dict % set ( ' F ' , ' ZZZZ ' ) call dict % set ( ' G ' , ' z ' ) call dict % set ( ' A ' , ' new value for A ' ) write ( * , ' (*(a,\"==>\",\"[\",a,\"]\",/)) ' ) & & ( trim ( dict % key ( i )) , & & dict % value ( i )( : dict % count ( i )) , & & i = 1 , size ( dict % key )) end program demo_set Results > G ==>[ z ] > F ==>[ ZZZZ ] > E ==>[ ZZ ] > D ==>[ c ] > C ==> [] > B ==>[ &#94; ] > A ==>[ new value for A ] AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: self character(len=*), intent(in) :: key character(len=*), intent(in) :: value Source Code type dictionary character ( len = :), allocatable :: key (:) character ( len = :), allocatable :: value (:) integer , allocatable :: count (:) contains procedure , public :: get => dict_get ! get value associated with a key in a dictionary or return blank procedure , public :: set => dict_add ! insert or replace entry by name into a dictionary procedure , public :: del => dict_delete ! delete entry by name from a dictionary if entry is present procedure , public :: clr => dict_clear ! clear dictionary procedure , public :: ifdef => dict_ifdef ! return if defined or not end type dictionary","tags":"","loc":"type/dictionary.html"},{"title":"test_suite_M_list – M_list","text":"subroutine test_suite_M_list() Uses M_list M_sort M_framework__verify Arguments None Contents Variables matched place share Subroutines test_dict_clr test_dict_delete test_dict_get test_dict_ifdef test_dict_set test_insert test_locate test_remove test_replace Source Code test_suite_M_list Variables Type Visibility Attributes Name Initial logical, public :: matched integer, public :: place character(len=*), public, parameter :: share = ' -library libGPF -filename `pwd`/M_list.FF -documentation y -ufpp y -ccall n -archive GPF.a' Subroutines subroutine test_dict_clr() Arguments None subroutine test_dict_delete() Arguments None subroutine test_dict_get() Arguments None subroutine test_dict_ifdef() Arguments None subroutine test_dict_set() Arguments None subroutine test_insert() Arguments None subroutine test_locate() Arguments None subroutine test_remove() Arguments None subroutine test_replace() Arguments None Source Code subroutine test_suite_M_list use M_sort , only : sort_shell use M_framework__verify , only : unit_test , unit_test_start , unit_test_end use M_list , only : locate , insert , remove , replace , dictionary character ( len =* ), parameter :: share = ' -library libGPF -filename `pwd`/M_list.FF -documentation y -ufpp y -ccall n -archive GPF.a' integer :: place logical :: matched ! list call test_locate () ! finds the index where a string is found or should be in a sorted array call test_insert () ! insert entry into a string array at specified position call test_remove () ! remove entry from an allocatable array at specified position call test_replace () ! replace entry in a string array at specified position ! dictionary call test_dict_set () ! add or replace a key-value pair in a dictionary call test_dict_delete () ! delete entry by key name from a basic dictionary call test_dict_get () ! value of key-value pair in a dictionary given key call test_dict_ifdef () ! return whether name is present in dictionary or not call test_dict_clr () ! clear basic dictionary ! contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dict_set type ( dictionary ) :: dict call unit_test_start ( 'dict%set' , 'add string into allocatable string array by name' , opts = share , matched = matched ) if (. not . matched ) return call dict % set ( 'A' , 'value for a' ) call unit_test ( 'dict%set' , all ( dict % key . eq .[ character ( len = 20 ) :: 'A' ]), msg = 'array should be A' ) call dict % set ( 'b' , 'value for b' ) call dict % set ( 'c' , 'value for c' ) call dict % set ( 'z' , 'value for z' ) call unit_test ( 'dict%set' , all ( dict % key . eq .[ character ( len = 20 ) :: 'z' , 'c' , 'b' , 'A' ]), 'array should be z c b A' ) call dict % set ( 'ZZ' , 'value for ZZ' ) call dict % set ( 'NOT' , 'not this one' ) call dict % set ( 'ZZZ' , 'value for ZZZ' ) call dict % set ( 'Z' , 'value for Z' ) call unit_test ( 'dict%set' , all ( dict % key . eq .[ character ( len = 20 ) :: 'z' , 'c' , 'b' , 'ZZZ' , 'ZZ' , 'Z' , 'NOT' , 'A' ]), 'strings ok' ) call unit_test_end ( 'dict%set' ) end subroutine test_dict_set !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dict_delete type ( dictionary ) :: dict call unit_test_start ( 'dict%del' , 'delete string by name from allocatable string array' , opts = share , matched = matched ) if (. not . matched ) return call dict % set ( 'A' , 'some A' ) call dict % set ( 'a' , 'some a' ) call dict % set ( 'b' , 'some b' ) call dict % set ( 'ZZ' , 'some ZZ' ) call dict % set ( 'ZZZ' , 'some ZZZ' ) call dict % set ( 'ZZ' , 'some ZZ' ) call dict % set ( 'Z' , 'some Z' ) call dict % set ( 'z' , 'some z' ) call dict % set ( 'c' , 'some c' ) !write(*,'(\"built \",a)')dict%key call dict % del ( 'A' ) call dict % del ( 'Z' ) call dict % del ( 'X' ) call dict % del ( 'ZZZ' ) call dict % del ( 'ZZ' ) call dict % del ( 'z' ) !write(*,'(\"remaining \",a)')dict%key call unit_test ( 'dict%del' , all ( dict % key . eq .[ character ( len = 20 ) :: 'c' , 'b' , 'a' ]), 'string deletes keys' ) !write(*,'(\"remaining key \",a)')dict%key !write(*,'(\"remaining val \",a)')dict%value call unit_test ( 'dict%del' , all ( dict % value . eq .[ character ( len = 20 ) :: 'some c' , 'some b' , 'some a' ]), 'string deletes values' ) call unit_test_end ( 'dict%del' ) end subroutine test_dict_delete !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dict_ifdef type ( dictionary ) :: tt logical , allocatable :: answers (:) call unit_test_start ( 'dict%ifdef' , 'return whether name is present in dictionary or not' , opts = share , matched = matched ) if (. not . matched ) return call tt % set ( 'A' , 'value for A' ) call tt % set ( 'B' , 'value for B' ) call tt % set ( 'C' , 'value for C' ) call tt % set ( 'D' , 'value for D' ) call tt % set ( 'E' , 'value for E' ) call tt % set ( 'F' , 'value for F' ) call tt % set ( 'G' , 'value for G' ) call tt % del ( 'F' ) call tt % del ( 'D' ) answers = [ tt % ifdef ( 'A' ), tt % ifdef ( 'B' ), tt % ifdef ( 'C' ), tt % ifdef ( 'D' ), tt % ifdef ( 'E' ), tt % ifdef ( 'F' ), tt % ifdef ( 'G' ), tt % ifdef ( 'H' )] call unit_test ( 'dict%' , all ( answers . eqv . [. true ., . true ., . true ., . false ., . true ., . false ., . true ., . false .]), 'ifdef tests' ) call unit_test_end ( 'dict%ifdef' ) end subroutine test_dict_ifdef !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dict_clr type ( dictionary ) :: tt logical , allocatable :: answers (:) call unit_test_start ( 'dict%ifdef' , 'return whether name is present in dictionary or not' , opts = share , matched = matched ) if (. not . matched ) return call tt % set ( 'A' , 'value for A' ) call tt % set ( 'B' , 'value for B' ) call tt % set ( 'C' , 'value for C' ) call tt % set ( 'D' , 'value for D' ) call tt % set ( 'E' , 'value for E' ) call tt % set ( 'F' , 'value for F' ) call tt % set ( 'G' , 'value for G' ) call tt % del ( 'F' ) call tt % del ( 'D' ) call tt % clr () answers = [ tt % ifdef ( 'A' ), tt % ifdef ( 'B' ), tt % ifdef ( 'C' ), tt % ifdef ( 'D' ), tt % ifdef ( 'E' ), tt % ifdef ( 'F' ), tt % ifdef ( 'G' ), tt % ifdef ( 'H' )] call unit_test ( 'dict%' , all ( answers . eqv . [. false ., . false ., . false ., . false ., . false ., . false ., . false ., . false .]), 'clr tests' ) call unit_test_end ( 'dict%clr' ) end subroutine test_dict_clr !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dict_get type ( dictionary ) :: dict character ( len = 20 ), allocatable :: val (:) call unit_test_start ( 'dict%get' , 'locate and get value by key name from dictionary' , opts = share , matched = matched ) if (. not . matched ) return call dict % set ( 'A' , 'some A' ) call dict % set ( 'Z' , 'some Z' ) call dict % set ( 'X' , 'some X' ) val = [ dict % get ( 'Z' ), dict % get ( 'A' ), dict % get ( 'X' )] !write(*,'(\"remaining \",a)')dict%key call unit_test ( 'dict%get' , all ( dict % key . eq .[ character ( len = 20 ) :: 'Z' , 'X' , 'A' ]), 'string get keys' ) call unit_test ( 'dict%get' , all ( dict % value . eq .[ character ( len = 20 ) :: 'some Z' , 'some X' , 'some A' ]), 'string get values ' ) call unit_test_end ( 'dict%get' ) end subroutine test_dict_get !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_locate character ( len = :), allocatable :: lst (:) lst = [ character ( len = 20 ) :: '' , 'ZZZ' , 'aaa' , 'b' , 'xxx' ] ! make sure sorted in descending order call sort_shell ( lst , order = 'd' ) call unit_test_start ( 'locate' , 'locate string in allocatable string array sorted in descending order' , opts = share , matched = matched ) if (. not . matched ) return call locate ( lst , 'ZZZ' , place ) call unit_test ( 'locate' , place . eq . 4 , 'ZZZ' , place , 'should be ' , 4 ) call locate ( lst , 'zqj' , place ) call unit_test ( 'locate' , place . eq . - 1 , 'zqj' , place , 'should be ' , - 1 ) call unit_test_end ( 'locate' ) end subroutine test_locate !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_insert implicit none character ( len = :), allocatable :: arr (:) integer :: place character ( len = :), allocatable :: newkey integer :: i1 , i2 call unit_test_start ( 'insert' , 'insert value into allocatable array by index\"  ' , opts = share , matched = matched ) if (. not . matched ) return ! make sure sorted in descending order arr = [ character ( len = 20 ) :: '' , 'ZZZ' , 'aaa' , 'b' , 'xxx' ] call sort_shell ( arr , order = 'd' ) newkey = 'NEW' i1 = size ( arr ) call locate ( arr , newkey , place ) ! find where string is or should be call unit_test ( 'insert' , place . lt . 0 , 'should not be located' , place ) if ( place . lt . 1 ) then ! if string was not found insert it call insert ( arr , newkey , abs ( place )) ! not found so insert call locate ( arr , newkey , place ) ! find where string is or should be if ( place . gt . 0 ) then call unit_test ( 'insert' , arr ( place ). eq . 'NEW' , arr ( place ), 'should be \"NEW\"' ) else call unit_test ( 'insert' ,. false ., arr ( place ), 'should be positive for \"NEW\"' ) endif else call unit_test ( 'insert' , place . le . 0 , 'found but should not have been' , place ) endif i2 = size ( arr ) call unit_test ( 'insert' , i1 + 1. eq . i2 , 'array now bigger' , i1 , 'to' , i2 ) call unit_test_end ( 'insert' ) end subroutine test_insert !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_remove use M_sort , only : sort_shell character ( len = :), allocatable :: arr (:) integer :: place integer :: isize call unit_test_start ( 'remove' , 'remove value from allocatable array by index\"  ' , opts = share , matched = matched ) if (. not . matched ) return arr = [ character ( len = 20 ) :: '' , 'ZZZ' , 'Z' , 'aaa' , 'b' , 'x' , 'ab' , 'bb' , 'xxx' ] call sort_shell ( arr , order = 'd' ) ! make sure sorted in descending order isize = size ( arr ) call locate ( arr , 'ab' , place ) ! find where string is or should be call unit_test ( 'remove' , place . gt . 0 , 'found the element to remove' , place ) call remove ( arr , place ) call locate ( arr , 'ab' , place ) ! find where string is or should be call unit_test ( 'remove' , place . lt . 0 , 'did not find the element to remove' , place ) call locate ( arr , 'bb' , place ) ! find where string is or should be call remove ( arr , place ) call unit_test ( 'remove' , isize - 2. eq . size ( arr ), 'shrunk by two' ) call unit_test_end ( 'remove' ) end subroutine test_remove !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_replace use M_sort , only : sort_shell character ( len = :), allocatable :: arr (:) integer :: place1 integer :: isize call unit_test_start ( 'replace' , 'replace value from allocatable array by index\"  ' , opts = share , matched = matched ) if (. not . matched ) return arr = [ character ( len = 20 ) :: '' , 'ZZZ' , 'Z' , 'aaa' , 'b' , 'x' , 'ab' , 'bb' , 'xxx' ] call sort_shell ( arr , order = 'd' ) ! make sure sorted in descending order isize = size ( arr ) call locate ( arr , 'ab' , place1 ) ! find where string is or should be call unit_test ( 'replace' , place1 . gt . 0 , 'location=' , place1 ) call replace ( arr , 'new value for ab' , place1 ) ! add 0+ to avoid gfortran-11 bug call unit_test ( 'replace' , size ( arr ). eq . isize , 'no change in size' , 0 + size ( arr )) if ( place1 . gt . 0. and . place1 . le . isize ) then call unit_test ( 'replace' , arr ( place1 ). eq . 'new value for ab' , arr ( place1 )) else call unit_test ( 'replace' ,. false ., 'bad location' , place1 ) endif call unit_test_end ( 'replace' ) end subroutine test_replace !=================================================================================================================================== end subroutine test_suite_M_list","tags":"","loc":"proc/test_suite_m_list.html"},{"title":"insert – M_list","text":"public interface insert Contents Module Procedures insert_c insert_d insert_r insert_i insert_l Module Procedures private  subroutine insert_c(list, value, place) NAME insert ( 3 f ) - [ M_list ] insert entry into a string array at specified position ( LICENSE : PD ) SYNOPSIS subroutine insert(list,value,place) character(len=*)|doubleprecision|real|integer,intent(in) :: value\ncharacter(len=:)|doubleprecision|real|integer,intent(in) :: list(:)\ninteger,intent(in)    :: place DESCRIPTION Insert a value into an allocatable array at the specified index.\nThe list and value must be of the same type (CHARACTER, DOUBLEPRECISION,\nREAL, or INTEGER) OPTIONS list    is the list array. Must be sorted in descending order.\nvalue   the value to place in the array\nPLACE   is the subscript that the entry should be placed at EXAMPLES Find if a string is in a sorted array, and insert the string into\n   the list if it is not present … program demo_insert use M_sort , only : sort_shell use M_list , only : locate , insert implicit none character ( len = : ) , allocatable :: arr ( : ) integer :: i arr = [ character ( len = 20 ) :: '' , ' ZZZ ' , ' aaa ' , ' b ' , ' xxx ' ] ! make sure sorted in descending order call sort_shell ( arr , order = ' d ' ) ! add or replace values call update ( arr , ' b ' ) call update ( arr , ' [ ' ) call update ( arr , ' c ' ) call update ( arr , ' ZZ ' ) call update ( arr , ' ZZZ ' ) call update ( arr , ' ZZZZ ' ) call update ( arr , '' ) call update ( arr , ' z ' ) contains subroutine update ( arr , string ) character ( len = : ) , allocatable :: arr ( : ) character ( len =* ) :: string integer :: place , end end = size ( arr ) ! find where string is or should be call locate ( arr , string , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( arr , string , abs ( place )) endif ! show array end = size ( arr ) write ( * , ' (\"array is now SIZE=\",i0,1x,*(a,\",\")) ' ) end , ( trim ( arr ( i )) , i = 1 , end ) end subroutine update end program demo_insert Results > array is now SIZE=5 xxx,b,aaa,ZZZ,,\n    > array is now SIZE=6 xxx,b,aaa,[,ZZZ,,\n    > array is now SIZE=7 xxx,c,b,aaa,[,ZZZ,,\n    > array is now SIZE=8 xxx,c,b,aaa,[,ZZZ,ZZ,,\n    > array is now SIZE=9 xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,\n    > array is now SIZE=10 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,, AUTHOR 1989 , 2017 John S . Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: list (:) character(len=*), intent(in) :: value integer, intent(in) :: place private  subroutine insert_d(list, value, place) Arguments Type Intent Optional Attributes Name doubleprecision, allocatable :: list (:) doubleprecision, intent(in) :: value integer, intent(in) :: place private  subroutine insert_r(list, value, place) Arguments Type Intent Optional Attributes Name real, allocatable :: list (:) real, intent(in) :: value integer, intent(in) :: place private  subroutine insert_i(list, value, place) Arguments Type Intent Optional Attributes Name integer, allocatable :: list (:) integer, intent(in) :: value integer, intent(in) :: place private  subroutine insert_l(list, value, place) Arguments Type Intent Optional Attributes Name logical, allocatable :: list (:) logical, intent(in) :: value integer, intent(in) :: place","tags":"","loc":"interface/insert.html"},{"title":"locate – M_list","text":"public interface locate Contents Module Procedures locate_c locate_d locate_r locate_i Module Procedures private  subroutine locate_c(list, value, place, ier, errmsg) NAME locate ( 3 f ) - [ M_list ] finds the index where a string is found or should be in a sorted array ( LICENSE : PD ) SYNOPSIS subroutine locate(list,value,place,ier,errmsg) character(len=:)|doubleprecision|real|integer,allocatable :: list(:)\ncharacter(len=*)|doubleprecision|real|integer,intent(in)  :: value\ninteger, intent(out)                  :: PLACE\n\ninteger, intent(out),optional         :: IER\ncharacter(len=*),intent(out),optional :: ERRMSG DESCRIPTION LOCATE ( 3 f ) finds the index where the VALUE is found or should be found in an array . The array must be sorted in descending order ( highest at top ) . If VALUE is not found it returns the index where the name should be placed at with a negative sign . The array and list must be of the same type ( CHARACTER , DOUBLEPRECISION , REAL , INTEGER ) OPTIONS VALUE         the value to locate in the list.\nLIST          is the list array. RETURNS PLACE is the subscript that the entry was found at if it is greater than zero ( 0 ) . If PLACE is negative , the absolute value of PLACE indicates the subscript value where the new entry should be placed in order to keep the list alphabetized . IER is zero ( 0 ) if no error occurs . If an error occurs and IER is not present , the program is stopped . ERRMSG description of any error EXAMPLES Find if a string is in a sorted array, and insert the string into\n   the list if it is not present … program demo_locate use M_sort , only : sort_shell use M_list , only : locate implicit none character ( len = : ) , allocatable :: arr ( : ) integer :: i arr = [ character ( len = 20 ) :: '' , ' ZZZ ' , ' aaa ' , ' b ' , ' xxx ' ] ! make sure sorted in descending order call sort_shell ( arr , order = ' d ' ) call update ( arr , ' b ' ) call update ( arr , ' [ ' ) call update ( arr , ' c ' ) call update ( arr , ' ZZ ' ) call update ( arr , ' ZZZZ ' ) call update ( arr , ' z ' ) contains subroutine update ( arr , string ) character ( len = : ) , allocatable :: arr ( : ) character ( len =* ) :: string integer :: place , plus , ii , end ! find where string is or should be call locate ( arr , string , place ) write ( * , * ) ' for \" ' // string // ' \" index is ' , place , size ( arr ) ! if string was not found insert it if ( place . lt . 1 ) then plus = abs ( place ) ii = len ( arr ) end = size ( arr ) ! empty array if ( end . eq . 0 ) then arr = [ character ( len = ii ) :: string ] ! put in front of array elseif ( plus . eq . 1 ) then arr = [ character ( len = ii ) :: string , arr ] ! put at end of array elseif ( plus . eq . end ) then arr = [ character ( len = ii ) :: arr , string ] ! put in middle of array else arr = [ character ( len = ii ) :: arr ( : plus - 1 ) , string , arr ( plus : ) ] endif ! show array write ( * , ' (\"SIZE=\",i0,1x,*(a,\",\")) ' ) end , ( trim ( arr ( i )) , i = 1 , end ) endif end subroutine update end program demo_locate Results > for \" b \" index is 2 5 > for \" [ \" index is - 4 5 > SIZE = 5 xxx , b , aaa ,[, ZZZ , > for \" c \" index is - 2 6 > SIZE = 6 xxx , c , b , aaa ,[, ZZZ , > for \" ZZ \" index is - 7 7 > SIZE = 7 xxx , c , b , aaa ,[, ZZZ ,, > for \" ZZZZ \" index is - 6 8 > SIZE = 8 xxx , c , b , aaa ,[, ZZZZ , ZZZ ,, > for \" z \" index is - 1 9 > SIZE = 9 z , xxx , c , b , aaa ,[, ZZZZ , ZZZ ,, AUTHOR 1989 , 2017 John S . Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: list (:) character(len=*), intent(in) :: value integer, intent(out) :: place integer, intent(out), optional :: ier character(len=*), intent(out), optional :: errmsg private  subroutine locate_d(list, value, place, ier, errmsg) Arguments Type Intent Optional Attributes Name doubleprecision, allocatable :: list (:) doubleprecision, intent(in) :: value integer, intent(out) :: place integer, intent(out), optional :: ier character(len=*), intent(out), optional :: errmsg private  subroutine locate_r(list, value, place, ier, errmsg) Arguments Type Intent Optional Attributes Name real, allocatable :: list (:) real, intent(in) :: value integer, intent(out) :: place integer, intent(out), optional :: ier character(len=*), intent(out), optional :: errmsg private  subroutine locate_i(list, value, place, ier, errmsg) Arguments Type Intent Optional Attributes Name integer, allocatable :: list (:) integer, intent(in) :: value integer, intent(out) :: place integer, intent(out), optional :: ier character(len=*), intent(out), optional :: errmsg","tags":"","loc":"interface/locate.html"},{"title":"remove – M_list","text":"public interface remove Contents Module Procedures remove_c remove_d remove_r remove_i remove_l Module Procedures private  subroutine remove_c(list, place) NAME remove ( 3 f ) - [ M_list ] remove entry from an allocatable array at specified position ( LICENSE : PD ) SYNOPSIS subroutine remove(list,place) character(len=:)|doubleprecision|real|integer,intent(inout) :: list(:)\ninteger, intent(out) :: PLACE DESCRIPTION Remove a value from an allocatable array at the specified index.\nThe array is assumed to be sorted in descending order. It may be of\ntype CHARACTER, DOUBLEPRECISION, REAL, or INTEGER. OPTIONS list is the list array . PLACE is the subscript for the entry that should be removed EXAMPLES Sample program program demo_remove use M_sort , only : sort_shell use M_list , only : locate , remove implicit none character ( len = : ) , allocatable :: arr ( : ) integer :: i integer :: end arr = [ character ( len = 20 ) :: '' , ' ZZZ ' , ' Z ' , ' aaa ' , ' b ' , ' b ' , ' ab ' , ' bb ' , ' xxx ' ] ! make sure sorted in descending order call sort_shell ( arr , order = ' d ' ) end = size ( arr ) write ( * , ' (\"SIZE=\",i0,1x,*(a,\",\")) ' ) end , ( trim ( arr ( i )) , i = 1 , end ) call remove ( arr , 1 ) end = size ( arr ) write ( * , ' (\"SIZE=\",i0,1x,*(a,\",\")) ' ) end , ( trim ( arr ( i )) , i = 1 , end ) call remove ( arr , 4 ) end = size ( arr ) write ( * , ' (\"SIZE=\",i0,1x,*(a,\",\")) ' ) end , ( trim ( arr ( i )) , i = 1 , end ) end program demo_remove Results > SIZE=9 xxx,bb,b,b,ab,aaa,ZZZ,Z,,\n   > SIZE=8 bb,b,b,ab,aaa,ZZZ,Z,,\n   > SIZE=7 bb,b,b,aaa,ZZZ,Z,, AUTHOR 1989 , 2017 John S . Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: list (:) integer, intent(in) :: place private  subroutine remove_d(list, place) Arguments Type Intent Optional Attributes Name doubleprecision, allocatable :: list (:) integer, intent(in) :: place private  subroutine remove_r(list, place) Arguments Type Intent Optional Attributes Name real, allocatable :: list (:) integer, intent(in) :: place private  subroutine remove_i(list, place) Arguments Type Intent Optional Attributes Name integer, allocatable :: list (:) integer, intent(in) :: place private  subroutine remove_l(list, place) Arguments Type Intent Optional Attributes Name logical, allocatable :: list (:) integer, intent(in) :: place","tags":"","loc":"interface/remove.html"},{"title":"replace – M_list","text":"public interface replace Contents Module Procedures replace_c replace_d replace_r replace_i replace_l Module Procedures private  subroutine replace_c(list, value, place) NAME replace ( 3 f ) - [ M_list ] replace entry in a string array at specified position ( LICENSE : PD ) SYNOPSIS subroutine replace(list,value,place) character(len=*)|doubleprecision|real|integer,intent(in) :: value\ncharacter(len=:)|doubleprecision|real|integer,intent(in) :: list(:)\ninteger, intent(out)          :: PLACE DESCRIPTION replace a value in an allocatable array at the specified index . Unless the array needs the string length to increase this is merely an assign of a value to an array element . The array may be of type CHARACTER , DOUBLEPRECISION , REAL , or INTEGER . It is assumed to be sorted in descending order without duplicate values . The value and list must be of the same type . OPTIONS VALUE         the value to place in the array\nLIST          is the array.\nPLACE         is the subscript that the entry should be placed at EXAMPLES Replace key-value pairs in a dictionary program demo_replace use M_list , only : insert , locate , replace ! Find if a key is in a list and insert it ! into the key list and value list if it is not present ! or replace the associated value if the key existed implicit none character ( len = 20 ) :: key character ( len = 100 ) :: val character ( len = : ) , allocatable :: keywords ( : ) character ( len = : ) , allocatable :: values ( : ) integer :: i integer :: place call update ( ' b ' , ' value of b ' ) call update ( ' a ' , ' value of a ' ) call update ( ' c ' , ' value of c ' ) call update ( ' c ' , ' value of c again ' ) call update ( ' d ' , ' value of d ' ) call update ( ' a ' , ' value of a again ' ) ! show array write ( * , ' (*(a,\"==>\",a,/)) ' ) & & ( trim ( keywords ( i )) , trim ( values ( i )) , i = 1 , size ( keywords )) call locate ( keywords , ' a ' , place ) if ( place . gt . 0 ) then write ( * , * ) ' The value of \"a\" is ' , trim ( values ( place )) else write ( * , * ) ' \"a\" not found ' endif contains subroutine update ( key , val ) character ( len =* ) , intent ( in ) :: key character ( len =* ) , intent ( in ) :: val integer :: place ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , abs ( place )) call insert ( values , val , abs ( place )) else ! replace call replace ( values , val , place ) endif end subroutine update end program demo_replace Results > d==>value of d\n> c==>value of c again\n> b==>value of b\n> a==>value of a again AUTHOR 1989 , 2017 John S . Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: list (:) character(len=*), intent(in) :: value integer, intent(in) :: place private  subroutine replace_d(list, value, place) Arguments Type Intent Optional Attributes Name doubleprecision, allocatable :: list (:) doubleprecision, intent(in) :: value integer, intent(in) :: place private  subroutine replace_r(list, value, place) Arguments Type Intent Optional Attributes Name real, allocatable :: list (:) real, intent(in) :: value integer, intent(in) :: place private  subroutine replace_i(list, value, place) Arguments Type Intent Optional Attributes Name integer, allocatable :: list (:) integer, intent(in) :: value integer, intent(in) :: place private  subroutine replace_l(list, value, place) Arguments Type Intent Optional Attributes Name logical, allocatable :: list (:) logical, intent(in) :: value integer, intent(in) :: place","tags":"","loc":"interface/replace.html"},{"title":"update – M_list","text":"subroutine update(arr, string) Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: arr (:) character(len=*) :: string Contents Variables end ii place plus Source Code update Variables Type Visibility Attributes Name Initial integer, public :: end integer, public :: ii integer, public :: place integer, public :: plus Source Code subroutine update ( arr , string ) character ( len = :), allocatable :: arr (:) character ( len =* ) :: string integer :: place , plus , ii , end ! find where string is or should be call locate ( arr , string , place ) write ( * , * ) 'for \"' // string // '\" index is ' , place , size ( arr ) ! if string was not found insert it if ( place . lt . 1 ) then plus = abs ( place ) ii = len ( arr ) end = size ( arr ) ! empty array if ( end . eq . 0 ) then arr = [ character ( len = ii ) :: string ] ! put in front of array elseif ( plus . eq . 1 ) then arr = [ character ( len = ii ) :: string , arr ] ! put at end of array elseif ( plus . eq . end ) then arr = [ character ( len = ii ) :: arr , string ] ! put in middle of array else arr = [ character ( len = ii ) :: arr (: plus - 1 ), string , arr ( plus :) ] endif ! show array write ( * , '(\"SIZE=\",i0,1x,*(a,\",\"))' ) end ,( trim ( arr ( i )), i = 1 , end ) endif end subroutine update","tags":"","loc":"proc/update.html"},{"title":"update – M_list","text":"subroutine update(key, val) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in) :: val Contents Variables place Source Code update Variables Type Visibility Attributes Name Initial integer, public :: place Source Code subroutine update ( key , val ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ) :: val integer :: place ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , abs ( place )) call insert ( values , val , abs ( place )) else ! replace call replace ( values , val , place ) endif end subroutine update","tags":"","loc":"proc/update~2.html"},{"title":"get – M_list","text":"function get(key) result(valout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value character(len=:), allocatable Contents Variables place Source Code get Variables Type Visibility Attributes Name Initial integer, public :: place Source Code function get ( key ) result ( valout ) character ( len =* ), intent ( in ) :: key character ( len = :), allocatable :: valout integer :: place ! find where string is or should be call locate ( keywords , key , place ) if ( place . lt . 1 ) then valout = '' else valout = values ( place )(: counts ( place )) endif end function get","tags":"","loc":"proc/get.html"},{"title":"update – M_list","text":"subroutine update(key, valin) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in), optional :: valin Contents Variables ilen place val Source Code update Variables Type Visibility Attributes Name Initial integer, public :: ilen integer, public :: place character(len=:), public, allocatable :: val Source Code subroutine update ( key , valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin integer :: place integer :: ilen character ( len = :), allocatable :: val if ( present ( valin )) then val = valin ilen = len_trim ( val ) ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( counts , ilen , iabs ( place )) else call replace ( values , val , place ) call replace ( counts , ilen , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( counts , place ) endif endif end subroutine update","tags":"","loc":"proc/update~3.html"},{"title":"print_dict – M_list","text":"subroutine print_dict() Arguments None Contents Variables i Source Code print_dict Variables Type Visibility Attributes Name Initial integer, public :: i Source Code subroutine print_dict () integer :: i ! the dictionary is just three arrays write ( * , '(\"DICTIONARY:\")' ) write ( * , '(*(a,\"==>\",\"[\",a,\"]\",/))' ) & & ( trim ( table % key ( i )), & & table % value ( i )(: table % count ( i )), & & i = 1 , size ( table % key )) ! end subroutine print_dict","tags":"","loc":"proc/print_dict.html"},{"title":"update – M_list","text":"subroutine update(arr, string) Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: arr (:) character(len=*) :: string Contents Variables end place Source Code update Variables Type Visibility Attributes Name Initial integer, public :: end integer, public :: place Source Code subroutine update ( arr , string ) character ( len = :), allocatable :: arr (:) character ( len =* ) :: string integer :: place , end end = size ( arr ) ! find where string is or should be call locate ( arr , string , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( arr , string , abs ( place )) endif ! show array end = size ( arr ) write ( * , '(\"array is now SIZE=\",i0,1x,*(a,\",\"))' ) end ,( trim ( arr ( i )), i = 1 , end ) end subroutine update","tags":"","loc":"proc/update~4.html"},{"title":"test_suite_M_list – M_list","text":"interface subroutine test_suite_M_list() Arguments None","tags":"","loc":"interface/test_suite_m_list.html"},{"title":"M_list – M_list","text":"NAME M_list(3f) - [M_list::INTRO] maintain simple lists\n(LICENSE:PD) SYNOPSIS use M_list, only : insert, replace, remove, locate\nuse M_list, only : dictionary DESCRIPTION The M_list ( 3 fm ) module allows for maintaining an allocatable array of intrinsic type ( REAL , INTEGER , CHARACTER ) as a sorted list . An example is given that creates a keyword - value dictionary using the lists . The lists are maintained as simple allocatable arrays . Each time an entry is added or deleted the array is re - allocated . Because of the expense of reallocating the data these routines are best suited for maintaining small lists that do not change size frequently . The advantage of this simplistic approach is that the dictionary components are simple arrays of intrinsic types which can be easily accessed with standard routines . It is easy to understand , as it works with simple arrays . For more demanding applications this would be implemented as a linked list , which there are a number of freely available examples of ; several are listed on the Fortran Wiki. BASIC LIST subroutine locate ( list , value , place , ier , errmsg ) finds the index where a value is found or should be in a sorted array and flag if the value exists already subroutine insert ( list , value , place ) insert entry into an allocatable array at specified position subroutine replace ( list , value , place ) replace entry in an allocatable array at specified position subroutine remove ( list , place ) remove entry from an allocatable array at specified position EXAMPLES Sample program program demo_M_list use M_list , only : insert , locate , replace , remove ! create a dictionary with character keywords , values , and value lengths ! using the routines for maintaining a list use M_list , only : locate , insert , replace implicit none character ( len = : ) , allocatable :: keywords ( : ) character ( len = : ) , allocatable :: values ( : ) integer , allocatable :: counts ( : ) integer :: i ! insert and replace entries call update ( ' b ' , ' value of b ' ) call update ( ' a ' , ' value of a ' ) call update ( ' c ' , ' value of c ' ) call update ( ' c ' , ' value of c again ' ) call update ( ' d ' , ' value of d ' ) call update ( ' a ' , ' value of a again ' ) ! show array write ( * , ' (*(a,\"==>\",\"[\",a,\"]\",/)) ' ) & & ( trim ( keywords ( i )) , values ( i )( : counts ( i )) , i = 1 , size ( keywords )) ! remove some entries call update ( ' a ' ) call update ( ' c ' ) write ( * , ' (*(a,\"==>\",\"[\",a,\"]\",/)) ' ) & & ( trim ( keywords ( i )) , values ( i )( : counts ( i )) , i = 1 , size ( keywords )) ! get some values write ( * , * ) ' get b=> ' , get ( ' b ' ) write ( * , * ) ' get d=> ' , get ( ' d ' ) write ( * , * ) ' get notthere=> ' , get ( ' notthere ' ) ! contains subroutine update ( key , valin ) character ( len =* ) , intent ( in ) :: key character ( len =* ) , intent ( in ) , optional :: valin integer :: place integer :: ilen character ( len = : ) , allocatable :: val if ( present ( valin )) then val = valin ilen = len_trim ( val ) ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( counts , ilen , iabs ( place )) else call replace ( values , val , place ) call replace ( counts , ilen , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( counts , place ) endif endif end subroutine update function get ( key ) result ( valout ) character ( len =* ) , intent ( in ) :: key character ( len = : ) , allocatable :: valout integer :: place ! find where string is or should be call locate ( keywords , key , place ) if ( place . lt . 1 ) then valout = '' else valout = values ( place )( : counts ( place )) endif end function get end program demo_M_list Results > d ==> [ value of d ] > c ==> [ value of c again ] > b ==> [ value of b ] > a ==> [ value of a again ] > > d ==> [ value of d ] > b ==> [ value of b ] > > get b => value of b > get d => value of d > get notthere => BASIC DICTIONARY A basic dictionary that uses the basic M_list functions . Consider using generic linked - list based dictionaries when heavy usage is required , now that that is available in more recent versions of Fortran . Note : this does not work with gfortran ( 1 ) up to at least 7.4.0 but works from at least 10.3.0 and onward . Dictionary type definition : type dictionary character ( len =: ), allocatable :: key ( : ) character ( len =: ), allocatable :: value ( : ) integer , allocatable :: count ( : ) contains procedure , public :: get => dict_get procedure , public :: set => dict_add procedure , public :: del => dict_delete procedure , public :: clr => dict_clear end type dictionary %get get value from type ( dictionary ) given an existing key %set set or replace value for type ( dictionary ) given a key %del delete an existing key from type ( dictionary ) %clr empty a type ( dictionary ) %ifdef test if name is defined EXAMPLES Sample program program test_dictionary use M_list , only : dictionary implicit none type ( dictionary ) :: table ! ! create a character string dictionary ! call table % set ( ' A ' , ' aye ' ) call table % set ( ' B ' , ' bee ' ) call table % set ( ' C ' , ' see ' ) call table % set ( ' D ' , ' dee ' ) ! write ( * , * ) ' A= ' , table % get ( ' A ' ) write ( * , * ) ' C= ' , table % get ( ' C ' ) write ( * , * ) ' notthere= ' , table % get ( ' notthere ' ) ! call print_dict () ! ! delete dictionary entries ! call table % del ( ' A ' ) call table % del ( ' C ' ) call table % del ( ' z ' ) ! a noop as there is no key of ' z ' ! call print_dict () ! ! clear dictionary ! call table % clr () ! call print_dict () ! contains ! subroutine print_dict () integer :: i ! the dictionary is just three arrays write ( * , ' (\"DICTIONARY:\") ' ) write ( * , ' (*(a,\"==>\",\"[\",a,\"]\",/)) ' ) & & ( trim ( table % key ( i )) , & & table % value ( i )( : table % count ( i )) , & & i = 1 , size ( table % key )) ! end subroutine print_dict ! end program test_dictionary AUTHOR John S. Urban LICENSE Public Domain Uses iso_fortran_env Contents Interfaces insert locate remove replace Derived Types dictionary Interfaces public        interface insert private  subroutine insert_c(list, value, place) NAME insert ( 3 f ) - [ M_list ] insert entry into a string array at specified position ( LICENSE : PD ) SYNOPSIS subroutine insert(list,value,place) character(len=*)|doubleprecision|real|integer,intent(in) :: value\ncharacter(len=:)|doubleprecision|real|integer,intent(in) :: list(:)\ninteger,intent(in)    :: place DESCRIPTION Insert a value into an allocatable array at the specified index.\nThe list and value must be of the same type (CHARACTER, DOUBLEPRECISION,\nREAL, or INTEGER) OPTIONS list    is the list array. Must be sorted in descending order.\nvalue   the value to place in the array\nPLACE   is the subscript that the entry should be placed at EXAMPLES Find if a string is in a sorted array, and insert the string into\n   the list if it is not present … program demo_insert use M_sort , only : sort_shell use M_list , only : locate , insert implicit none character ( len = : ) , allocatable :: arr ( : ) integer :: i arr = [ character ( len = 20 ) :: '' , ' ZZZ ' , ' aaa ' , ' b ' , ' xxx ' ] ! make sure sorted in descending order call sort_shell ( arr , order = ' d ' ) ! add or replace values call update ( arr , ' b ' ) call update ( arr , ' [ ' ) call update ( arr , ' c ' ) call update ( arr , ' ZZ ' ) call update ( arr , ' ZZZ ' ) call update ( arr , ' ZZZZ ' ) call update ( arr , '' ) call update ( arr , ' z ' ) contains subroutine update ( arr , string ) character ( len = : ) , allocatable :: arr ( : ) character ( len =* ) :: string integer :: place , end end = size ( arr ) ! find where string is or should be call locate ( arr , string , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( arr , string , abs ( place )) endif ! show array end = size ( arr ) write ( * , ' (\"array is now SIZE=\",i0,1x,*(a,\",\")) ' ) end , ( trim ( arr ( i )) , i = 1 , end ) end subroutine update end program demo_insert Results > array is now SIZE=5 xxx,b,aaa,ZZZ,,\n    > array is now SIZE=6 xxx,b,aaa,[,ZZZ,,\n    > array is now SIZE=7 xxx,c,b,aaa,[,ZZZ,,\n    > array is now SIZE=8 xxx,c,b,aaa,[,ZZZ,ZZ,,\n    > array is now SIZE=9 xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,\n    > array is now SIZE=10 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,, AUTHOR 1989 , 2017 John S . Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: list (:) character(len=*), intent(in) :: value integer, intent(in) :: place private  subroutine insert_d(list, value, place) Arguments Type Intent Optional Attributes Name doubleprecision, allocatable :: list (:) doubleprecision, intent(in) :: value integer, intent(in) :: place private  subroutine insert_r(list, value, place) Arguments Type Intent Optional Attributes Name real, allocatable :: list (:) real, intent(in) :: value integer, intent(in) :: place private  subroutine insert_i(list, value, place) Arguments Type Intent Optional Attributes Name integer, allocatable :: list (:) integer, intent(in) :: value integer, intent(in) :: place private  subroutine insert_l(list, value, place) Arguments Type Intent Optional Attributes Name logical, allocatable :: list (:) logical, intent(in) :: value integer, intent(in) :: place public        interface locate private  subroutine locate_c(list, value, place, ier, errmsg) NAME locate ( 3 f ) - [ M_list ] finds the index where a string is found or should be in a sorted array ( LICENSE : PD ) SYNOPSIS subroutine locate(list,value,place,ier,errmsg) character(len=:)|doubleprecision|real|integer,allocatable :: list(:)\ncharacter(len=*)|doubleprecision|real|integer,intent(in)  :: value\ninteger, intent(out)                  :: PLACE\n\ninteger, intent(out),optional         :: IER\ncharacter(len=*),intent(out),optional :: ERRMSG DESCRIPTION LOCATE ( 3 f ) finds the index where the VALUE is found or should be found in an array . The array must be sorted in descending order ( highest at top ) . If VALUE is not found it returns the index where the name should be placed at with a negative sign . The array and list must be of the same type ( CHARACTER , DOUBLEPRECISION , REAL , INTEGER ) OPTIONS VALUE         the value to locate in the list.\nLIST          is the list array. RETURNS PLACE is the subscript that the entry was found at if it is greater than zero ( 0 ) . If PLACE is negative , the absolute value of PLACE indicates the subscript value where the new entry should be placed in order to keep the list alphabetized . IER is zero ( 0 ) if no error occurs . If an error occurs and IER is not present , the program is stopped . ERRMSG description of any error EXAMPLES Find if a string is in a sorted array, and insert the string into\n   the list if it is not present … program demo_locate use M_sort , only : sort_shell use M_list , only : locate implicit none character ( len = : ) , allocatable :: arr ( : ) integer :: i arr = [ character ( len = 20 ) :: '' , ' ZZZ ' , ' aaa ' , ' b ' , ' xxx ' ] ! make sure sorted in descending order call sort_shell ( arr , order = ' d ' ) call update ( arr , ' b ' ) call update ( arr , ' [ ' ) call update ( arr , ' c ' ) call update ( arr , ' ZZ ' ) call update ( arr , ' ZZZZ ' ) call update ( arr , ' z ' ) contains subroutine update ( arr , string ) character ( len = : ) , allocatable :: arr ( : ) character ( len =* ) :: string integer :: place , plus , ii , end ! find where string is or should be call locate ( arr , string , place ) write ( * , * ) ' for \" ' // string // ' \" index is ' , place , size ( arr ) ! if string was not found insert it if ( place . lt . 1 ) then plus = abs ( place ) ii = len ( arr ) end = size ( arr ) ! empty array if ( end . eq . 0 ) then arr = [ character ( len = ii ) :: string ] ! put in front of array elseif ( plus . eq . 1 ) then arr = [ character ( len = ii ) :: string , arr ] ! put at end of array elseif ( plus . eq . end ) then arr = [ character ( len = ii ) :: arr , string ] ! put in middle of array else arr = [ character ( len = ii ) :: arr ( : plus - 1 ) , string , arr ( plus : ) ] endif ! show array write ( * , ' (\"SIZE=\",i0,1x,*(a,\",\")) ' ) end , ( trim ( arr ( i )) , i = 1 , end ) endif end subroutine update end program demo_locate Results > for \" b \" index is 2 5 > for \" [ \" index is - 4 5 > SIZE = 5 xxx , b , aaa ,[, ZZZ , > for \" c \" index is - 2 6 > SIZE = 6 xxx , c , b , aaa ,[, ZZZ , > for \" ZZ \" index is - 7 7 > SIZE = 7 xxx , c , b , aaa ,[, ZZZ ,, > for \" ZZZZ \" index is - 6 8 > SIZE = 8 xxx , c , b , aaa ,[, ZZZZ , ZZZ ,, > for \" z \" index is - 1 9 > SIZE = 9 z , xxx , c , b , aaa ,[, ZZZZ , ZZZ ,, AUTHOR 1989 , 2017 John S . Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: list (:) character(len=*), intent(in) :: value integer, intent(out) :: place integer, intent(out), optional :: ier character(len=*), intent(out), optional :: errmsg private  subroutine locate_d(list, value, place, ier, errmsg) Arguments Type Intent Optional Attributes Name doubleprecision, allocatable :: list (:) doubleprecision, intent(in) :: value integer, intent(out) :: place integer, intent(out), optional :: ier character(len=*), intent(out), optional :: errmsg private  subroutine locate_r(list, value, place, ier, errmsg) Arguments Type Intent Optional Attributes Name real, allocatable :: list (:) real, intent(in) :: value integer, intent(out) :: place integer, intent(out), optional :: ier character(len=*), intent(out), optional :: errmsg private  subroutine locate_i(list, value, place, ier, errmsg) Arguments Type Intent Optional Attributes Name integer, allocatable :: list (:) integer, intent(in) :: value integer, intent(out) :: place integer, intent(out), optional :: ier character(len=*), intent(out), optional :: errmsg public        interface remove private  subroutine remove_c(list, place) NAME remove ( 3 f ) - [ M_list ] remove entry from an allocatable array at specified position ( LICENSE : PD ) SYNOPSIS subroutine remove(list,place) character(len=:)|doubleprecision|real|integer,intent(inout) :: list(:)\ninteger, intent(out) :: PLACE DESCRIPTION Remove a value from an allocatable array at the specified index.\nThe array is assumed to be sorted in descending order. It may be of\ntype CHARACTER, DOUBLEPRECISION, REAL, or INTEGER. OPTIONS list is the list array . PLACE is the subscript for the entry that should be removed EXAMPLES Sample program program demo_remove use M_sort , only : sort_shell use M_list , only : locate , remove implicit none character ( len = : ) , allocatable :: arr ( : ) integer :: i integer :: end arr = [ character ( len = 20 ) :: '' , ' ZZZ ' , ' Z ' , ' aaa ' , ' b ' , ' b ' , ' ab ' , ' bb ' , ' xxx ' ] ! make sure sorted in descending order call sort_shell ( arr , order = ' d ' ) end = size ( arr ) write ( * , ' (\"SIZE=\",i0,1x,*(a,\",\")) ' ) end , ( trim ( arr ( i )) , i = 1 , end ) call remove ( arr , 1 ) end = size ( arr ) write ( * , ' (\"SIZE=\",i0,1x,*(a,\",\")) ' ) end , ( trim ( arr ( i )) , i = 1 , end ) call remove ( arr , 4 ) end = size ( arr ) write ( * , ' (\"SIZE=\",i0,1x,*(a,\",\")) ' ) end , ( trim ( arr ( i )) , i = 1 , end ) end program demo_remove Results > SIZE=9 xxx,bb,b,b,ab,aaa,ZZZ,Z,,\n   > SIZE=8 bb,b,b,ab,aaa,ZZZ,Z,,\n   > SIZE=7 bb,b,b,aaa,ZZZ,Z,, AUTHOR 1989 , 2017 John S . Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: list (:) integer, intent(in) :: place private  subroutine remove_d(list, place) Arguments Type Intent Optional Attributes Name doubleprecision, allocatable :: list (:) integer, intent(in) :: place private  subroutine remove_r(list, place) Arguments Type Intent Optional Attributes Name real, allocatable :: list (:) integer, intent(in) :: place private  subroutine remove_i(list, place) Arguments Type Intent Optional Attributes Name integer, allocatable :: list (:) integer, intent(in) :: place private  subroutine remove_l(list, place) Arguments Type Intent Optional Attributes Name logical, allocatable :: list (:) integer, intent(in) :: place public        interface replace private  subroutine replace_c(list, value, place) NAME replace ( 3 f ) - [ M_list ] replace entry in a string array at specified position ( LICENSE : PD ) SYNOPSIS subroutine replace(list,value,place) character(len=*)|doubleprecision|real|integer,intent(in) :: value\ncharacter(len=:)|doubleprecision|real|integer,intent(in) :: list(:)\ninteger, intent(out)          :: PLACE DESCRIPTION replace a value in an allocatable array at the specified index . Unless the array needs the string length to increase this is merely an assign of a value to an array element . The array may be of type CHARACTER , DOUBLEPRECISION , REAL , or INTEGER . It is assumed to be sorted in descending order without duplicate values . The value and list must be of the same type . OPTIONS VALUE         the value to place in the array\nLIST          is the array.\nPLACE         is the subscript that the entry should be placed at EXAMPLES Replace key-value pairs in a dictionary program demo_replace use M_list , only : insert , locate , replace ! Find if a key is in a list and insert it ! into the key list and value list if it is not present ! or replace the associated value if the key existed implicit none character ( len = 20 ) :: key character ( len = 100 ) :: val character ( len = : ) , allocatable :: keywords ( : ) character ( len = : ) , allocatable :: values ( : ) integer :: i integer :: place call update ( ' b ' , ' value of b ' ) call update ( ' a ' , ' value of a ' ) call update ( ' c ' , ' value of c ' ) call update ( ' c ' , ' value of c again ' ) call update ( ' d ' , ' value of d ' ) call update ( ' a ' , ' value of a again ' ) ! show array write ( * , ' (*(a,\"==>\",a,/)) ' ) & & ( trim ( keywords ( i )) , trim ( values ( i )) , i = 1 , size ( keywords )) call locate ( keywords , ' a ' , place ) if ( place . gt . 0 ) then write ( * , * ) ' The value of \"a\" is ' , trim ( values ( place )) else write ( * , * ) ' \"a\" not found ' endif contains subroutine update ( key , val ) character ( len =* ) , intent ( in ) :: key character ( len =* ) , intent ( in ) :: val integer :: place ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , abs ( place )) call insert ( values , val , abs ( place )) else ! replace call replace ( values , val , place ) endif end subroutine update end program demo_replace Results > d==>value of d\n> c==>value of c again\n> b==>value of b\n> a==>value of a again AUTHOR 1989 , 2017 John S . Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: list (:) character(len=*), intent(in) :: value integer, intent(in) :: place private  subroutine replace_d(list, value, place) Arguments Type Intent Optional Attributes Name doubleprecision, allocatable :: list (:) doubleprecision, intent(in) :: value integer, intent(in) :: place private  subroutine replace_r(list, value, place) Arguments Type Intent Optional Attributes Name real, allocatable :: list (:) real, intent(in) :: value integer, intent(in) :: place private  subroutine replace_i(list, value, place) Arguments Type Intent Optional Attributes Name integer, allocatable :: list (:) integer, intent(in) :: value integer, intent(in) :: place private  subroutine replace_l(list, value, place) Arguments Type Intent Optional Attributes Name logical, allocatable :: list (:) logical, intent(in) :: value integer, intent(in) :: place Derived Types type, public :: dictionary Components Type Visibility Attributes Name Initial integer, public, allocatable :: count (:) character(len=:), public, allocatable :: key (:) character(len=:), public, allocatable :: value (:) Type-Bound Procedures procedure\n                    ,                  public\n                  :: clr =>\n                    dict_clear Subroutine procedure\n                    ,                  public\n                  :: del =>\n                    dict_delete Subroutine procedure\n                    ,                  public\n                  :: get =>\n                    dict_get Function procedure\n                    ,                  public\n                  :: ifdef =>\n                    dict_ifdef Function procedure\n                    ,                  public\n                  :: set =>\n                    dict_add Subroutine","tags":"","loc":"module/m_list.html"},{"title":"demo_clr – M_list","text":"Uses M_list Contents Variables caps i Source Code demo_clr Variables Type Attributes Name Initial type( dictionary ) :: caps integer :: i Source Code program demo_clr use M_list , only : dictionary implicit none type ( dictionary ) :: caps integer :: i ! create a character string dictionary call caps % set ( 'A' , 'aye' ) call caps % set ( 'B' , 'bee' ) call caps % set ( 'C' , 'see' ) call caps % set ( 'D' , 'dee' ) ! show current dictionary write ( * , '(\"DICTIONARY BEFORE CLEARED\")' ) write ( * , 101 )( trim ( caps % key ( i )), trim ( caps % value ( i )), i = 1 , size ( caps % key )) call caps % clr () write ( * , '(\"DICTIONARY AFTER CLEARED\")' ) ! show current dictionary write ( * , 101 )( trim ( caps % key ( i )), trim ( caps % value ( i )), i = 1 , size ( caps % key )) 101 format ( 1 x , * ( a , \"='\" , a , \"'\" ,:, \",\" )) end program demo_clr","tags":"","loc":"program/demo_clr.html"},{"title":"demo_locate – M_list","text":"Uses M_list M_sort Contents Variables arr i Subroutines update Source Code demo_locate Variables Type Attributes Name Initial character(len=:), allocatable :: arr (:) integer :: i Subroutines subroutine update (arr, string) Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: arr (:) character(len=*) :: string Source Code program demo_locate use M_sort , only : sort_shell use M_list , only : locate implicit none character ( len = :), allocatable :: arr (:) integer :: i arr = [ character ( len = 20 ) :: '' , 'ZZZ' , 'aaa' , 'b' , 'xxx' ] ! make sure sorted in descending order call sort_shell ( arr , order = 'd' ) call update ( arr , 'b' ) call update ( arr , '[' ) call update ( arr , 'c' ) call update ( arr , 'ZZ' ) call update ( arr , 'ZZZZ' ) call update ( arr , 'z' ) contains subroutine update ( arr , string ) character ( len = :), allocatable :: arr (:) character ( len =* ) :: string integer :: place , plus , ii , end ! find where string is or should be call locate ( arr , string , place ) write ( * , * ) 'for \"' // string // '\" index is ' , place , size ( arr ) ! if string was not found insert it if ( place . lt . 1 ) then plus = abs ( place ) ii = len ( arr ) end = size ( arr ) ! empty array if ( end . eq . 0 ) then arr = [ character ( len = ii ) :: string ] ! put in front of array elseif ( plus . eq . 1 ) then arr = [ character ( len = ii ) :: string , arr ] ! put at end of array elseif ( plus . eq . end ) then arr = [ character ( len = ii ) :: arr , string ] ! put in middle of array else arr = [ character ( len = ii ) :: arr (: plus - 1 ), string , arr ( plus :) ] endif ! show array write ( * , '(\"SIZE=\",i0,1x,*(a,\",\"))' ) end ,( trim ( arr ( i )), i = 1 , end ) endif end subroutine update end program demo_locate","tags":"","loc":"program/demo_locate.html"},{"title":"demo_replace – M_list","text":"Uses M_list Contents Variables i key keywords place val values Subroutines update Source Code demo_replace Variables Type Attributes Name Initial integer :: i character(len=20) :: key character(len=:), allocatable :: keywords (:) integer :: place character(len=100) :: val character(len=:), allocatable :: values (:) Subroutines subroutine update (key, val) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in) :: val Source Code program demo_replace use M_list , only : insert , locate , replace ! Find if a key is in a list and insert it ! into the key list and value list if it is not present ! or replace the associated value if the key existed implicit none character ( len = 20 ) :: key character ( len = 100 ) :: val character ( len = :), allocatable :: keywords (:) character ( len = :), allocatable :: values (:) integer :: i integer :: place call update ( 'b' , 'value of b' ) call update ( 'a' , 'value of a' ) call update ( 'c' , 'value of c' ) call update ( 'c' , 'value of c again' ) call update ( 'd' , 'value of d' ) call update ( 'a' , 'value of a again' ) ! show array write ( * , '(*(a,\"==>\",a,/))' )& &( trim ( keywords ( i )), trim ( values ( i )), i = 1 , size ( keywords )) call locate ( keywords , 'a' , place ) if ( place . gt . 0 ) then write ( * , * ) 'The value of \"a\" is ' , trim ( values ( place )) else write ( * , * ) '\"a\" not found' endif contains subroutine update ( key , val ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ) :: val integer :: place ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , abs ( place )) call insert ( values , val , abs ( place )) else ! replace call replace ( values , val , place ) endif end subroutine update end program demo_replace","tags":"","loc":"program/demo_replace.html"},{"title":"demo_remove – M_list","text":"Uses M_list M_sort Contents Variables arr end i Source Code demo_remove Variables Type Attributes Name Initial character(len=:), allocatable :: arr (:) integer :: end integer :: i Source Code program demo_remove use M_sort , only : sort_shell use M_list , only : locate , remove implicit none character ( len = :), allocatable :: arr (:) integer :: i integer :: end arr = [ character ( len = 20 ) :: '' , 'ZZZ' , 'Z' , 'aaa' , 'b' , 'b' , 'ab' , 'bb' , 'xxx' ] ! make sure sorted in descending order call sort_shell ( arr , order = 'd' ) end = size ( arr ) write ( * , '(\"SIZE=\",i0,1x,*(a,\",\"))' ) end ,( trim ( arr ( i )), i = 1 , end ) call remove ( arr , 1 ) end = size ( arr ) write ( * , '(\"SIZE=\",i0,1x,*(a,\",\"))' ) end ,( trim ( arr ( i )), i = 1 , end ) call remove ( arr , 4 ) end = size ( arr ) write ( * , '(\"SIZE=\",i0,1x,*(a,\",\"))' ) end ,( trim ( arr ( i )), i = 1 , end ) end program demo_remove","tags":"","loc":"program/demo_remove.html"},{"title":"demo_M_list – M_list","text":"Uses M_list Contents Variables counts i keywords values Functions get Subroutines update Source Code demo_M_list Variables Type Attributes Name Initial integer, allocatable :: counts (:) integer :: i character(len=:), allocatable :: keywords (:) character(len=:), allocatable :: values (:) Functions function get (key) result(valout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value character(len=:), allocatable Subroutines subroutine update (key, valin) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key character(len=*), intent(in), optional :: valin Source Code program demo_M_list use M_list , only : insert , locate , replace , remove ! create a dictionary with character keywords, values, and value lengths ! using the routines for maintaining a list use M_list , only : locate , insert , replace implicit none character ( len = :), allocatable :: keywords (:) character ( len = :), allocatable :: values (:) integer , allocatable :: counts (:) integer :: i ! insert and replace entries call update ( 'b' , 'value of b' ) call update ( 'a' , 'value of a' ) call update ( 'c' , 'value of c' ) call update ( 'c' , 'value of c again' ) call update ( 'd' , 'value of d' ) call update ( 'a' , 'value of a again' ) ! show array write ( * , '(*(a,\"==>\",\"[\",a,\"]\",/))' )& & ( trim ( keywords ( i )), values ( i )(: counts ( i )), i = 1 , size ( keywords )) ! remove some entries call update ( 'a' ) call update ( 'c' ) write ( * , '(*(a,\"==>\",\"[\",a,\"]\",/))' )& & ( trim ( keywords ( i )), values ( i )(: counts ( i )), i = 1 , size ( keywords )) ! get some values write ( * , * ) 'get b=>' , get ( 'b' ) write ( * , * ) 'get d=>' , get ( 'd' ) write ( * , * ) 'get notthere=>' , get ( 'notthere' ) ! contains subroutine update ( key , valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin integer :: place integer :: ilen character ( len = :), allocatable :: val if ( present ( valin )) then val = valin ilen = len_trim ( val ) ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( counts , ilen , iabs ( place )) else call replace ( values , val , place ) call replace ( counts , ilen , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( counts , place ) endif endif end subroutine update function get ( key ) result ( valout ) character ( len =* ), intent ( in ) :: key character ( len = :), allocatable :: valout integer :: place ! find where string is or should be call locate ( keywords , key , place ) if ( place . lt . 1 ) then valout = '' else valout = values ( place )(: counts ( place )) endif end function get end program demo_M_list","tags":"","loc":"program/demo_m_list.html"},{"title":"test_dictionary – M_list","text":"Uses M_list Contents Variables table Subroutines print_dict Source Code test_dictionary Variables Type Attributes Name Initial type( dictionary ) :: table Subroutines subroutine print_dict () Arguments None Source Code program test_dictionary use M_list , only : dictionary implicit none type ( dictionary ) :: table ! ! create a character string dictionary ! call table % set ( 'A' , 'aye' ) call table % set ( 'B' , 'bee' ) call table % set ( 'C' , 'see' ) call table % set ( 'D' , 'dee' ) ! write ( * , * ) 'A=' , table % get ( 'A' ) write ( * , * ) 'C=' , table % get ( 'C' ) write ( * , * ) 'notthere=' , table % get ( 'notthere' ) ! call print_dict () ! ! delete dictionary entries ! call table % del ( 'A' ) call table % del ( 'C' ) call table % del ( 'z' ) ! a noop as there is no key of 'z' ! call print_dict () ! ! clear dictionary ! call table % clr () ! call print_dict () ! contains ! subroutine print_dict () integer :: i ! the dictionary is just three arrays write ( * , '(\"DICTIONARY:\")' ) write ( * , '(*(a,\"==>\",\"[\",a,\"]\",/))' ) & & ( trim ( table % key ( i )), & & table % value ( i )(: table % count ( i )), & & i = 1 , size ( table % key )) ! end subroutine print_dict ! end program test_dictionary","tags":"","loc":"program/test_dictionary.html"},{"title":"demo_insert – M_list","text":"Uses M_list M_sort Contents Variables arr i Subroutines update Source Code demo_insert Variables Type Attributes Name Initial character(len=:), allocatable :: arr (:) integer :: i Subroutines subroutine update (arr, string) Arguments Type Intent Optional Attributes Name character(len=:), allocatable :: arr (:) character(len=*) :: string Source Code program demo_insert use M_sort , only : sort_shell use M_list , only : locate , insert implicit none character ( len = :), allocatable :: arr (:) integer :: i arr = [ character ( len = 20 ) :: '' , 'ZZZ' , 'aaa' , 'b' , 'xxx' ] ! make sure sorted in descending order call sort_shell ( arr , order = 'd' ) ! add or replace values call update ( arr , 'b' ) call update ( arr , '[' ) call update ( arr , 'c' ) call update ( arr , 'ZZ' ) call update ( arr , 'ZZZ' ) call update ( arr , 'ZZZZ' ) call update ( arr , '' ) call update ( arr , 'z' ) contains subroutine update ( arr , string ) character ( len = :), allocatable :: arr (:) character ( len =* ) :: string integer :: place , end end = size ( arr ) ! find where string is or should be call locate ( arr , string , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( arr , string , abs ( place )) endif ! show array end = size ( arr ) write ( * , '(\"array is now SIZE=\",i0,1x,*(a,\",\"))' ) end ,( trim ( arr ( i )), i = 1 , end ) end subroutine update end program demo_insert","tags":"","loc":"program/demo_insert.html"},{"title":"demo_set – M_list","text":"Uses M_list Contents Variables dict i Source Code demo_set Variables Type Attributes Name Initial type( dictionary ) :: dict integer :: i Source Code program demo_set use M_list , only : dictionary implicit none type ( dictionary ) :: dict integer :: i call dict % set ( 'A' , 'b' ) call dict % set ( 'B' , '&#94;' ) call dict % set ( 'C' , ' ' ) call dict % set ( 'D' , 'c' ) call dict % set ( 'E' , 'ZZ' ) call dict % set ( 'F' , 'ZZZZ' ) call dict % set ( 'G' , 'z' ) call dict % set ( 'A' , 'new value for A' ) write ( * , '(*(a,\"==>\",\"[\",a,\"]\",/))' ) & & ( trim ( dict % key ( i )), & & dict % value ( i )(: dict % count ( i )), & & i = 1 , size ( dict % key )) end program demo_set","tags":"","loc":"program/demo_set.html"},{"title":"demo_del – M_list","text":"Uses M_list Contents Variables caps i Source Code demo_del Variables Type Attributes Name Initial type( dictionary ) :: caps integer :: i Source Code program demo_del use M_list , only : dictionary implicit none type ( dictionary ) :: caps integer :: i ! create a character string dictionary call caps % set ( 'A' , 'aye' ) call caps % set ( 'B' , 'bee' ) call caps % set ( 'C' , 'see' ) call caps % set ( 'D' , 'dee' ) ! show current dictionary write ( * , 101 )( trim ( caps % key ( i )), trim ( caps % value ( i )), i = 1 , size ( caps % key )) ! delete dictionary entries call caps % del ( 'A' ) call caps % del ( 'C' ) call caps % del ( 'z' ) ! a noop as there is no key of 'z' ! show current dictionary write ( * , 101 )( trim ( caps % key ( i )), trim ( caps % value ( i )), i = 1 , size ( caps % key )) 101 format ( 1 x , * ( a , \"='\" , a , \"'\" ,:, \",\" )) end program demo_del","tags":"","loc":"program/demo_del.html"},{"title":"demo_ifdef – M_list","text":"Uses M_list Contents Variables i table val Source Code demo_ifdef Variables Type Attributes Name Initial integer :: i type( dictionary ) :: table character(len=:), allocatable :: val Source Code program demo_ifdef use M_list , only : dictionary implicit none type ( dictionary ) :: table character ( len = :), allocatable :: val integer :: i call table % set ( 'A' , 'value for A' ) call table % set ( 'B' , 'value for B' ) call table % set ( 'C' , 'value for C' ) call table % set ( 'D' , 'value for D' ) call table % set ( 'E' , 'value for E' ) call table % set ( 'F' , 'value for F' ) call table % set ( 'G' , 'value for G' ) call table % del ( 'F' ) call table % del ( 'D' ) write ( * , * ) 'A=' , table % ifdef ( 'A' ) write ( * , * ) 'B=' , table % ifdef ( 'B' ) write ( * , * ) 'C=' , table % ifdef ( 'C' ) write ( * , * ) 'D=' , table % ifdef ( 'D' ) write ( * , * ) 'E=' , table % ifdef ( 'E' ) write ( * , * ) 'F=' , table % ifdef ( 'F' ) write ( * , * ) 'G=' , table % ifdef ( 'G' ) write ( * , * ) 'H=' , table % ifdef ( 'H' ) end program demo_ifdef","tags":"","loc":"program/demo_ifdef.html"},{"title":"demo_get – M_list","text":"Uses M_list Contents Variables i table val Source Code demo_get Variables Type Attributes Name Initial integer :: i type( dictionary ) :: table character(len=:), allocatable :: val Source Code program demo_get use M_list , only : dictionary implicit none type ( dictionary ) :: table character ( len = :), allocatable :: val integer :: i call table % set ( 'A' , 'value for A' ) call table % set ( 'B' , 'value for B' ) call table % set ( 'C' , 'value for C' ) call table % set ( 'D' , 'value for D' ) call table % set ( 'E' , 'value for E' ) call table % set ( 'F' , 'value for F' ) call table % set ( 'G' , 'value for G' ) write ( * , * ) 'A=' , table % get ( 'A' ) write ( * , * ) 'B=' , table % get ( 'B' ) write ( * , * ) 'C=' , table % get ( 'C' ) write ( * , * ) 'D=' , table % get ( 'D' ) write ( * , * ) 'E=' , table % get ( 'E' ) write ( * , * ) 'F=' , table % get ( 'F' ) write ( * , * ) 'G=' , table % get ( 'G' ) write ( * , * ) 'H=' , table % get ( 'H' ) end program demo_get","tags":"","loc":"program/demo_get.html"},{"title":"runtest – M_list","text":"Uses M_framework Contents Interfaces test_suite_M_list Source Code runtest Interfaces interface subroutine test_suite_M_list() Arguments None Source Code program runtest use M_framework , only : unit_test_stop interface ; subroutine test_suite_M_list (); end ; end interface call test_suite_M_list () call unit_test_stop () end program runtest","tags":"","loc":"program/runtest.html"},{"title":"M_list.f90 – M_list","text":"Contents Modules M_list Source Code M_list.f90 Source Code !> !!##NAME !!    M_list(3f) - [M_list::INTRO] maintain simple lists !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    use M_list, only : insert, replace, remove, locate !!    use M_list, only : dictionary !! !!##DESCRIPTION !! !!    The M_list(3fm) module allows for maintaining an allocatable array of !!    intrinsic type (REAL, INTEGER, CHARACTER) as a sorted list. An example !!    is given that creates a keyword-value dictionary using the lists. !! !!    The lists are maintained as simple allocatable arrays. Each time an !!    entry is added or deleted the array is re-allocated. Because of the !!    expense of reallocating the data these routines are best suited for !!    maintaining small lists that do not change size frequently. !! !!    The advantage of this simplistic approach is that the dictionary !!    components are simple arrays of intrinsic types which can be easily !!    accessed with standard routines. It is easy to understand, as it !!    works with simple arrays. For more demanding applications this would !!    be implemented as a linked list, which there are a number of freely !!    available examples of; several are listed on the Fortran Wiki. !! !!    BASIC LIST !! !!    subroutine locate(list,value,place,ier,errmsg)  finds the index where a !!                                                    value is found or should !!                                                    be in a sorted array and !!                                                    flag if the value exists !!                                                    already !!    subroutine insert(list,value,place)     insert entry into an allocatable !!                                            array at specified position !!    subroutine replace(list,value,place)    replace entry in an allocatable !!                                            array at specified position !!    subroutine remove(list,place)           remove entry from an allocatable !!                                            array at specified position !! !!##EXAMPLES !! !!   Sample program !! !!    program demo_M_list !!    use M_list, only : insert, locate, replace, remove !!    ! create a dictionary with character keywords, values, and value lengths !!    ! using the routines for maintaining a list !! !!     use M_list, only : locate, insert, replace !!     implicit none !!     character(len=:),allocatable   :: keywords(:) !!     character(len=:),allocatable   :: values(:) !!     integer,allocatable            :: counts(:) !!     integer                        :: i !!     ! insert and replace entries !!     call update('b','value of b') !!     call update('a','value of a') !!     call update('c','value of c') !!     call update('c','value of c again') !!     call update('d','value of d') !!     call update('a','value of a again') !!     ! show array !!     write(*,'(*(a,\"==>\",\"[\",a,\"]\",/))')& !!      & (trim(keywords(i)),values(i)(:counts(i)),i=1,size(keywords)) !!     ! remove some entries !!     call update('a') !!     call update('c') !!     write(*,'(*(a,\"==>\",\"[\",a,\"]\",/))')& !!      & (trim(keywords(i)),values(i)(:counts(i)),i=1,size(keywords)) !!     ! get some values !!     write(*,*)'get b=>',get('b') !!     write(*,*)'get d=>',get('d') !!     write(*,*)'get notthere=>',get('notthere') !!     ! !!     contains !!     subroutine update(key,valin) !!     character(len=*),intent(in)           :: key !!     character(len=*),intent(in),optional  :: valin !!     integer                               :: place !!     integer                               :: ilen !!     character(len=:),allocatable          :: val !!     if(present(valin))then !!        val=valin !!        ilen=len_trim(val) !!        ! find where string is or should be !!        call locate(keywords,key,place) !!        ! if string was not found insert it !!        if(place.lt.1)then !!           call insert(keywords,key,iabs(place)) !!           call insert(values,val,iabs(place)) !!           call insert(counts,ilen,iabs(place)) !!        else !!           call replace(values,val,place) !!           call replace(counts,ilen,place) !!        endif !!     else !!        call locate(keywords,key,place) !!        if(place.gt.0)then !!           call remove(keywords,place) !!           call remove(values,place) !!           call remove(counts,place) !!        endif !!     endif !!     end subroutine update !!     function get(key) result(valout) !!     character(len=*),intent(in)   :: key !!     character(len=:),allocatable  :: valout !!     integer                       :: place !!        ! find where string is or should be !!        call locate(keywords,key,place) !!        if(place.lt.1)then !!           valout='' !!        else !!           valout=values(place)(:counts(place)) !!        endif !!     end function get !!     end program demo_M_list !! !!   Results !! !!       >  d==>[value of d] !!       >  c==>[value of c again] !!       >  b==>[value of b] !!       >  a==>[value of a again] !!       > !!       > d==>[value of d] !!       > b==>[value of b] !!       > !!       >  get b=>value of b !!       >  get d=>value of d !!       >  get notthere=> !! !! !!    BASIC DICTIONARY !! !!    A basic dictionary that uses the basic M_list functions. !! !!    Consider using generic linked-list based dictionaries when heavy !!    usage is required, now that that is available in more recent versions !!    of Fortran. !! !!    Note: this does not work with gfortran(1) up to at least 7.4.0 but !!    works from at least 10.3.0 and onward. !! !!    Dictionary type definition: !! !!       type dictionary !!          character(len=:),allocatable :: key(:) !!          character(len=:),allocatable :: value(:) !!          integer,allocatable          :: count(:) !!          contains !!             procedure,public :: get => dict_get !!             procedure,public :: set => dict_add !!             procedure,public :: del => dict_delete !!             procedure,public :: clr => dict_clear !!       end type dictionary !! !!       %get      get value from type(dictionary) given an existing key !!       %set      set or replace value for type(dictionary) given a key !!       %del      delete an existing key from type(dictionary) !!       %clr      empty a type(dictionary) !!       %ifdef    test if name is defined !! !!##EXAMPLES !! !!   Sample program !! !!       program test_dictionary !!       use M_list, only : dictionary !!       implicit none !!       type(dictionary)             :: table !!         ! !!         ! create a character string dictionary !!         ! !!         call table%set('A','aye') !!         call table%set('B','bee') !!         call table%set('C','see') !!         call table%set('D','dee') !!         ! !!         write(*,*)'A=',table%get('A') !!         write(*,*)'C=',table%get('C') !!         write(*,*)'notthere=',table%get('notthere') !!         ! !!         call print_dict() !!         ! !!         ! delete dictionary entries !!         ! !!         call  table%del('A') !!         call  table%del('C') !!         call  table%del('z') ! a noop as there is no key of 'z' !!         ! !!         call print_dict() !!         ! !!         ! clear dictionary !!         ! !!         call  table%clr() !!         ! !!         call print_dict() !!       ! !!       contains !!       ! !!       subroutine print_dict() !!       integer :: i !!          ! the dictionary is just three arrays !!          write(*,'(\"DICTIONARY:\")') !!          write(*,'(*(a,\"==>\",\"[\",a,\"]\",/))') & !!          & (trim(table%key(i)),               & !!          & table%value(i)(:table%count(i)),    & !!          & i=1,size(table%key)) !!          ! !!       end subroutine print_dict !!       ! !!       end program test_dictionary !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== module M_list use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , stdout => OUTPUT_UNIT ! access computing environment implicit none private public locate ! [M_list] find PLACE in sorted character array where value can be found or should be placed private locate_c private locate_d private locate_r private locate_i public insert ! [M_list] insert entry into a sorted allocatable array at specified position private insert_c private insert_d private insert_r private insert_i private insert_l public replace ! [M_list] replace entry by index from a sorted allocatable array if it is present private replace_c private replace_d private replace_r private replace_i private replace_l public remove ! [M_list] delete entry by index from a sorted allocatable array if it is present private remove_c private remove_d private remove_r private remove_i private remove_l ! ident_1=\"@(#) M_list locate(3f) Generic subroutine locates where element is or should be in sorted allocatable array\" interface locate module procedure locate_c , locate_d , locate_r , locate_i end interface ! ident_2=\"@(#) M_list insert(3f) Generic subroutine inserts element into allocatable array at specified position\" interface insert module procedure insert_c , insert_d , insert_r , insert_i , insert_l end interface ! ident_3=\"@(#) M_list replace(3f) Generic subroutine replaces element from allocatable array at specified position\" interface replace module procedure replace_c , replace_d , replace_r , replace_i , replace_l end interface ! ident_4=\"@(#) M_list remove(3f) Generic subroutine deletes element from allocatable array at specified position\" interface remove module procedure remove_c , remove_d , remove_r , remove_i , remove_l end interface !----------------------------------------------------------------------------------------------------------------------------------- public dictionary type dictionary character ( len = :), allocatable :: key (:) character ( len = :), allocatable :: value (:) integer , allocatable :: count (:) contains procedure , public :: get => dict_get ! get value associated with a key in a dictionary or return blank procedure , public :: set => dict_add ! insert or replace entry by name into a dictionary procedure , public :: del => dict_delete ! delete entry by name from a dictionary if entry is present procedure , public :: clr => dict_clear ! clear dictionary procedure , public :: ifdef => dict_ifdef ! return if defined or not end type dictionary logical , save :: debug = . false . !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    locate(3f) - [M_list] finds the index where a string is found or !!                 should be in a sorted array !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!   subroutine locate(list,value,place,ier,errmsg) !! !!    character(len=:)|doubleprecision|real|integer,allocatable :: list(:) !!    character(len=*)|doubleprecision|real|integer,intent(in)  :: value !!    integer, intent(out)                  :: PLACE !! !!    integer, intent(out),optional         :: IER !!    character(len=*),intent(out),optional :: ERRMSG !! !!##DESCRIPTION !! !!    LOCATE(3f) finds the index where the VALUE is found or should !!    be found in an array. The array must be sorted in descending !!    order (highest at top). If VALUE is not found it returns the index !!    where the name should be placed at with a negative sign. !! !!    The array and list must be of the same type (CHARACTER, DOUBLEPRECISION, !!    REAL,INTEGER) !! !!##OPTIONS !! !!    VALUE         the value to locate in the list. !!    LIST          is the list array. !! !!##RETURNS !!    PLACE         is the subscript that the entry was found at if it is !!                  greater than zero(0). !! !!                  If PLACE is negative, the absolute value of !!                  PLACE indicates the subscript value where the !!                  new entry should be placed in order to keep the !!                  list alphabetized. !! !!    IER           is zero(0) if no error occurs. !!                  If an error occurs and IER is not !!                  present, the program is stopped. !! !!    ERRMSG        description of any error !! !!##EXAMPLES !! !!   Find if a string is in a sorted array, and insert the string into !!   the list if it is not present ... !! !!     program demo_locate !!     use M_sort, only : sort_shell !!     use M_list, only : locate !!     implicit none !!     character(len=:),allocatable  :: arr(:) !!     integer                       :: i !! !!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ] !!     ! make sure sorted in descending order !!     call sort_shell(arr,order='d') !! !!     call update(arr,'b') !!     call update(arr,'[') !!     call update(arr,'c') !!     call update(arr,'ZZ') !!     call update(arr,'ZZZZ') !!     call update(arr,'z') !! !!     contains !!     subroutine update(arr,string) !!     character(len=:),allocatable :: arr(:) !!     character(len=*)             :: string !!     integer                      :: place, plus, ii, end !!     ! find where string is or should be !!     call locate(arr,string,place) !!     write(*,*)'for \"'//string//'\" index is ',place, size(arr) !!     ! if string was not found insert it !!     if(place.lt.1)then !!        plus=abs(place) !!        ii=len(arr) !!        end=size(arr) !!        ! empty array !!        if(end.eq.0)then !!           arr=[character(len=ii) :: string ] !!        ! put in front of array !!        elseif(plus.eq.1)then !!           arr=[character(len=ii) :: string, arr] !!        ! put at end of array !!        elseif(plus.eq.end)then !!           arr=[character(len=ii) :: arr, string ] !!        ! put in middle of array !!        else !!           arr=[character(len=ii) :: arr(:plus-1), string,arr(plus:) ] !!        endif !!        ! show array !!        write(*,'(\"SIZE=\",i0,1x,*(a,\",\"))')end,(trim(arr(i)),i=1,end) !!     endif !!     end subroutine update !!     end program demo_locate !! !!   Results !! !!       >  for \"b\" index is            2           5 !!       >  for \"[\" index is           -4           5 !!       > SIZE=5 xxx,b,aaa,[,ZZZ, !!       >  for \"c\" index is           -2           6 !!       > SIZE=6 xxx,c,b,aaa,[,ZZZ, !!       >  for \"ZZ\" index is           -7           7 !!       > SIZE=7 xxx,c,b,aaa,[,ZZZ,, !!       >  for \"ZZZZ\" index is           -6           8 !!       > SIZE=8 xxx,c,b,aaa,[,ZZZZ,ZZZ,, !!       >  for \"z\" index is           -1           9 !!       > SIZE=9 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,, !! !!##AUTHOR !!    1989,2017 John S. Urban !!##LICENSE !!    Public Domain subroutine locate_c ( list , value , place , ier , errmsg ) ! ident_5=\"@(#) M_list locate_c(3f) find PLACE in sorted character array where VALUE can be found or should be placed\" character ( len =* ), intent ( in ) :: value integer , intent ( out ) :: place character ( len = :), allocatable :: list (:) integer , intent ( out ), optional :: ier character ( len =* ), intent ( out ), optional :: errmsg integer :: i character ( len = :), allocatable :: message integer :: arraysize integer :: maxtry integer :: imin , imax integer :: error if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif arraysize = size ( list ) if ( debug ) write ( stderr , * ) '*locate_c* START ARRAYSIZE=' , size ( list ) error = 0 if ( arraysize . eq . 0 ) then maxtry = 0 place =- 1 else maxtry = nint ( log ( float ( arraysize )) / log ( 2.0 ) + 1.0 ) place = ( arraysize + 1 ) / 2 endif imin = 1 imax = arraysize message = '' LOOP : block do i = 1 , maxtry if ( value . eq . list ( PLACE )) then exit LOOP else if ( value . gt . list ( place )) then imax = place - 1 else imin = place + 1 endif if ( imin . gt . imax ) then place =- imin if ( iabs ( place ). gt . arraysize ) then ! ran off end of list. Where new value should go or an unsorted input array' exit LOOP endif exit LOOP endif place = ( imax + imin ) / 2 if ( place . gt . arraysize . or . place . le . 0 ) then message = '*locate* error: search is out of bounds of list. Probably an unsorted input array' error =- 1 exit LOOP endif enddo message = '*locate* exceeded allowed tries. Probably an unsorted input array' endblock LOOP if ( present ( ier )) then ier = error else if ( error . ne . 0 ) then write ( stderr , * ) message // ' VALUE=' , trim ( value ) // ' PLACE=' , place stop 1 endif if ( present ( errmsg )) then errmsg = message endif if ( debug ) write ( stderr , * ) '*locate_c* END PLACE=' , place , ' ARRAYSIZE=' , size ( list ), ' LENGTH=' , len ( list ) end subroutine locate_c subroutine locate_d ( list , value , place , ier , errmsg ) ! ident_6=\"@(#) M_list locate_d(3f) find PLACE in sorted doubleprecision array where VALUE can be found or should be placed\" ! Assuming an array sorted in descending order ! !  1. If it is not found report where it should be placed as a NEGATIVE index number. doubleprecision , allocatable :: list (:) doubleprecision , intent ( in ) :: value integer , intent ( out ) :: place integer , intent ( out ), optional :: ier character ( len =* ), intent ( out ), optional :: errmsg integer :: i character ( len = :), allocatable :: message integer :: arraysize integer :: maxtry integer :: imin , imax integer :: error message = '' if (. not . allocated ( list )) then list = [ doubleprecision :: ] endif arraysize = size ( list ) if ( debug ) write ( stderr , * ) '*locate_d* START ARRAYSIZE=' , size ( list ) error = 0 if ( arraysize . eq . 0 ) then maxtry = 0 place =- 1 else maxtry = nint ( log ( float ( arraysize )) / log ( 2.0 ) + 1.0 ) place = ( arraysize + 1 ) / 2 endif imin = 1 imax = arraysize message = '' LOOP : block do i = 1 , maxtry if ( value . eq . list ( PLACE )) then exit LOOP else if ( value . gt . list ( place )) then imax = place - 1 else imin = place + 1 endif if ( imin . gt . imax ) then place =- imin if ( iabs ( place ). gt . arraysize ) then ! ran off end of list. Where new value should go or an unsorted input array' exit LOOP endif exit LOOP endif place = ( imax + imin ) / 2 if ( place . gt . arraysize . or . place . le . 0 ) then message = '*locate* error: search is out of bounds of list. Probably an unsorted input array' error =- 1 exit LOOP endif enddo message = '*locate* exceeded allowed tries. Probably an unsorted input array' endblock LOOP if ( present ( ier )) then ier = error else if ( error . ne . 0 ) then write ( stderr , * ) message // ' VALUE=' , value , ' PLACE=' , place stop 1 endif if ( present ( errmsg )) then errmsg = message endif if ( debug ) write ( stderr , * ) '*locate_d* END PLACE=' , place , ' ARRAYSIZE=' , size ( list ) end subroutine locate_d subroutine locate_r ( list , value , place , ier , errmsg ) ! ident_7=\"@(#) M_list locate_r(3f) find PLACE in sorted real array where VALUE can be found or should be placed\" ! Assuming an array sorted in descending order ! !  1. If it is not found report where it should be placed as a NEGATIVE index number. real , allocatable :: list (:) real , intent ( in ) :: value integer , intent ( out ) :: place integer , intent ( out ), optional :: ier character ( len =* ), intent ( out ), optional :: errmsg integer :: i character ( len = :), allocatable :: message integer :: arraysize integer :: maxtry integer :: imin , imax integer :: error if (. not . allocated ( list )) then list = [ real :: ] endif arraysize = size ( list ) if ( debug ) write ( stderr , * ) '*locate_r* START ARRAYSIZE=' , size ( list ) error = 0 if ( arraysize . eq . 0 ) then maxtry = 0 place =- 1 else maxtry = nint ( log ( float ( arraysize )) / log ( 2.0 ) + 1.0 ) place = ( arraysize + 1 ) / 2 endif imin = 1 imax = arraysize message = '' LOOP : block do i = 1 , maxtry if ( value . eq . list ( PLACE )) then exit LOOP else if ( value . gt . list ( place )) then imax = place - 1 else imin = place + 1 endif if ( imin . gt . imax ) then place =- imin if ( iabs ( place ). gt . arraysize ) then ! ran off end of list. Where new value should go or an unsorted input array' exit LOOP endif exit LOOP endif place = ( imax + imin ) / 2 if ( place . gt . arraysize . or . place . le . 0 ) then message = '*locate* error: search is out of bounds of list. Probably an unsorted input array' error =- 1 exit LOOP endif enddo message = '*locate* exceeded allowed tries. Probably an unsorted input array' endblock LOOP if ( present ( ier )) then ier = error else if ( error . ne . 0 ) then write ( stderr , * ) message // ' VALUE=' , value , ' PLACE=' , place stop 1 endif if ( present ( errmsg )) then errmsg = message endif if ( debug ) write ( stderr , * ) '*locate_r* END PLACE=' , place , ' ARRAYSIZE=' , size ( list ) end subroutine locate_r subroutine locate_i ( list , value , place , ier , errmsg ) ! ident_8=\"@(#) M_list locate_i(3f) find PLACE in sorted integer array where VALUE can be found or should be placed\" ! Assuming an array sorted in descending order ! !  1. If it is not found report where it should be placed as a NEGATIVE index number. integer , allocatable :: list (:) integer , intent ( in ) :: value integer , intent ( out ) :: place integer , intent ( out ), optional :: ier character ( len =* ), intent ( out ), optional :: errmsg integer :: i character ( len = :), allocatable :: message integer :: arraysize integer :: maxtry integer :: imin , imax integer :: error if (. not . allocated ( list )) then list = [ integer :: ] endif arraysize = size ( list ) if ( debug ) write ( stderr , * ) '*locate_i* START ARRAYSIZE=' , size ( list ) error = 0 if ( arraysize . eq . 0 ) then maxtry = 0 place =- 1 else maxtry = nint ( log ( float ( arraysize )) / log ( 2.0 ) + 1.0 ) place = ( arraysize + 1 ) / 2 endif imin = 1 imax = arraysize message = '' LOOP : block do i = 1 , maxtry if ( value . eq . list ( PLACE )) then exit LOOP else if ( value . gt . list ( place )) then imax = place - 1 else imin = place + 1 endif if ( imin . gt . imax ) then place =- imin if ( iabs ( place ). gt . arraysize ) then ! ran off end of list. Where new value should go or an unsorted input array' exit LOOP endif exit LOOP endif place = ( imax + imin ) / 2 if ( place . gt . arraysize . or . place . le . 0 ) then message = '*locate* error: search is out of bounds of list. Probably an unsorted input array' error =- 1 exit LOOP endif enddo message = '*locate* exceeded allowed tries. Probably an unsorted input array' endblock LOOP if ( present ( ier )) then ier = error else if ( error . ne . 0 ) then write ( stderr , * ) message // ' VALUE=' , value , ' PLACE=' , place stop 1 endif if ( present ( errmsg )) then errmsg = message endif if ( debug ) write ( stderr , * ) '*locate_i* END PLACE=' , place , ' ARRAYSIZE=' , size ( list ) end subroutine locate_i !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    remove(3f) - [M_list] remove entry from an allocatable array at !!                 specified position !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!   subroutine remove(list,place) !! !!    character(len=:)|doubleprecision|real|integer,intent(inout) :: list(:) !!    integer, intent(out) :: PLACE !! !!##DESCRIPTION !! !!    Remove a value from an allocatable array at the specified index. !!    The array is assumed to be sorted in descending order. It may be of !!    type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER. !! !!##OPTIONS !! !!    list    is the list array. !!    PLACE   is the subscript for the entry that should be removed !! !!##EXAMPLES !! !!   Sample program !! !!     program demo_remove !!     use M_sort, only : sort_shell !!     use M_list, only : locate, remove !!     implicit none !!     character(len=:),allocatable :: arr(:) !!     integer                       :: i !!     integer                       :: end !! !!     arr=[character(len=20) :: '','ZZZ','Z','aaa','b','b','ab','bb','xxx' ] !!     ! make sure sorted in descending order !!     call sort_shell(arr,order='d') !! !!     end=size(arr) !!     write(*,'(\"SIZE=\",i0,1x,*(a,\",\"))')end,(trim(arr(i)),i=1,end) !!     call remove(arr,1) !!     end=size(arr) !!     write(*,'(\"SIZE=\",i0,1x,*(a,\",\"))')end,(trim(arr(i)),i=1,end) !!     call remove(arr,4) !!     end=size(arr) !!     write(*,'(\"SIZE=\",i0,1x,*(a,\",\"))')end,(trim(arr(i)),i=1,end) !! !!     end program demo_remove !! !!   Results !! !!       > SIZE=9 xxx,bb,b,b,ab,aaa,ZZZ,Z,, !!       > SIZE=8 bb,b,b,ab,aaa,ZZZ,Z,, !!       > SIZE=7 bb,b,b,aaa,ZZZ,Z,, !! !!##AUTHOR !!    1989,2017 John S. Urban !!##LICENSE !!    Public Domain subroutine remove_c ( list , place ) ! ident_9=\"@(#) M_list remove_c(3fp) remove string from allocatable string array at specified position\" character ( len = :), allocatable :: list (:) integer , intent ( in ) :: place integer :: ii , end if ( debug ) write ( stderr , * ) '*remove_c* START PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if (. not . allocated ( list )) then list = [ character ( len = 2 ) :: ] endif ii = len ( list ) end = size ( list ) if ( place . le . 0. or . place . gt . end ) then ! index out of bounds of array elseif ( place . eq . end ) then ! remove from array list = [ character ( len = ii ) :: list (: place - 1 ) ] else list = [ character ( len = ii ) :: list (: place - 1 ), list ( place + 1 :) ] endif if ( debug ) write ( stderr , * ) '*remove_c* END PLACE=' , place , ' NEWSIZE=' , size ( list ), ' LENGTH=' , len ( list ) end subroutine remove_c subroutine remove_d ( list , place ) ! ident_10=\"@(#) M_list remove_d(3fp) remove doubleprecision value from allocatable array at specified position\" doubleprecision , allocatable :: list (:) integer , intent ( in ) :: place integer :: end if ( debug ) write ( stderr , * ) '*remove_d* START PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if (. not . allocated ( list )) then list = [ doubleprecision :: ] endif end = size ( list ) if ( place . le . 0. or . place . gt . end ) then ! index out of bounds of array elseif ( place . eq . end ) then ! remove from array list = [ list (: place - 1 )] else list = [ list (: place - 1 ), list ( place + 1 :) ] endif if ( debug ) write ( stderr , * ) '*remove_d* END PLACE=' , place , ' NEWSIZE=' , size ( list ) end subroutine remove_d subroutine remove_r ( list , place ) ! ident_11=\"@(#) M_list remove_r(3fp) remove value from allocatable array at specified position\" real , allocatable :: list (:) integer , intent ( in ) :: place integer :: end if ( debug ) write ( stderr , * ) '*remove_r* START PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if (. not . allocated ( list )) then list = [ real :: ] endif end = size ( list ) if ( place . le . 0. or . place . gt . end ) then ! index out of bounds of array elseif ( place . eq . end ) then ! remove from array list = [ list (: place - 1 )] else list = [ list (: place - 1 ), list ( place + 1 :) ] endif if ( debug ) write ( stderr , * ) '*remove_r* END PLACE=' , place , ' NEWSIZE=' , size ( list ) end subroutine remove_r subroutine remove_l ( list , place ) ! ident_12=\"@(#) M_list remove_l(3fp) remove value from allocatable array at specified position\" logical , allocatable :: list (:) integer , intent ( in ) :: place integer :: end if ( debug ) write ( stderr , * ) '*remove_l* START PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if (. not . allocated ( list )) then list = [ logical :: ] endif end = size ( list ) if ( place . le . 0. or . place . gt . end ) then ! index out of bounds of array elseif ( place . eq . end ) then ! remove from array list = [ list (: place - 1 )] else list = [ list (: place - 1 ), list ( place + 1 :) ] endif if ( debug ) write ( stderr , * ) '*remove_l* END PLACE=' , place , ' NEWSIZE=' , size ( list ) end subroutine remove_l subroutine remove_i ( list , place ) ! ident_13=\"@(#) M_list remove_i(3fp) remove value from allocatable array at specified position\" integer , allocatable :: list (:) integer , intent ( in ) :: place integer :: end if ( debug ) write ( stderr , * ) '*remove_i* START PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if (. not . allocated ( list )) then list = [ integer :: ] endif end = size ( list ) if ( place . le . 0. or . place . gt . end ) then ! index out of bounds of array elseif ( place . eq . end ) then ! remove from array list = [ list (: place - 1 )] else list = [ list (: place - 1 ), list ( place + 1 :) ] endif if ( debug ) write ( stderr , * ) '*remove_i* END PLACE=' , place , ' NEWSIZE=' , size ( list ) end subroutine remove_i !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    replace(3f) - [M_list] replace entry in a string array at specified position !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!   subroutine replace(list,value,place) !! !!    character(len=*)|doubleprecision|real|integer,intent(in) :: value !!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:) !!    integer, intent(out)          :: PLACE !! !!##DESCRIPTION !! !!    replace a value in an allocatable array at the specified index. Unless !!    the array needs the string length to increase this is merely an assign !!    of a value to an array element. !! !!    The array may be of type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER. !!    It is assumed to be sorted in descending order without duplicate !!    values. !! !!    The value and list must be of the same type. !! !!##OPTIONS !! !!    VALUE         the value to place in the array !!    LIST          is the array. !!    PLACE         is the subscript that the entry should be placed at !! !!##EXAMPLES !! !!   Replace key-value pairs in a dictionary !! !!     program demo_replace !!     use M_list, only  : insert, locate, replace !!     ! Find if a key is in a list and insert it !!     ! into the key list and value list if it is not present !!     ! or replace the associated value if the key existed !!     implicit none !!     character(len=20)            :: key !!     character(len=100)           :: val !!     character(len=:),allocatable :: keywords(:) !!     character(len=:),allocatable :: values(:) !!     integer                      :: i !!     integer                      :: place !!     call update('b','value of b') !!     call update('a','value of a') !!     call update('c','value of c') !!     call update('c','value of c again') !!     call update('d','value of d') !!     call update('a','value of a again') !!     ! show array !!     write(*,'(*(a,\"==>\",a,/))')& !!            &(trim(keywords(i)),trim(values(i)),i=1,size(keywords)) !! !!     call locate(keywords,'a',place) !!     if(place.gt.0)then !!        write(*,*)'The value of \"a\" is ',trim(values(place)) !!     else !!        write(*,*)'\"a\" not found' !!     endif !! !!     contains !!     subroutine update(key,val) !!     character(len=*),intent(in)  :: key !!     character(len=*),intent(in)  :: val !!     integer                      :: place !! !!     ! find where string is or should be !!     call locate(keywords,key,place) !!     ! if string was not found insert it !!     if(place.lt.1)then !!        call insert(keywords,key,abs(place)) !!        call insert(values,val,abs(place)) !!     else ! replace !!        call replace(values,val,place) !!     endif !! !!     end subroutine update !!    end program demo_replace !! !!   Results !! !!    > d==>value of d !!    > c==>value of c again !!    > b==>value of b !!    > a==>value of a again !! !!##AUTHOR !!    1989,2017 John S. Urban !!##LICENSE !!    Public Domain subroutine replace_c ( list , value , place ) ! ident_14=\"@(#) M_list replace_c(3fp) replace string in allocatable string array at specified position\" character ( len =* ), intent ( in ) :: value character ( len = :), allocatable :: list (:) character ( len = :), allocatable :: kludge (:) integer , intent ( in ) :: place integer :: ii integer :: tlen integer :: end if ( debug ) write ( stderr , * ) '*replace_c* START VALUE=' , trim ( value ), ' PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif tlen = len_trim ( value ) end = size ( list ) if ( place . lt . 0. or . place . gt . end ) then write ( stderr , * ) '*replace_c* error: index out of range. end=' , end , ' index=' , place elseif ( len_trim ( value ). le . len ( list )) then list ( place ) = value else ! increase length of variable ii = max ( tlen , len ( list )) kludge = [ character ( len = ii ) :: list ] list = kludge list ( place ) = value endif if ( debug ) write ( stderr , * ) '*replace_c* END VALUE=' , trim ( value ), ' PLACE=' , place , ' NEWSIZE=' , size ( list ), ' LENGTH=' , len ( list ) end subroutine replace_c subroutine replace_d ( list , value , place ) ! ident_15=\"@(#) M_list replace_d(3fp) place doubleprecision value into allocatable array at specified position\" doubleprecision , intent ( in ) :: value doubleprecision , allocatable :: list (:) integer , intent ( in ) :: place integer :: end if ( debug ) write ( stderr , * ) '*replace_d* START VALUE=' , value , ' PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if (. not . allocated ( list )) then list = [ doubleprecision :: ] endif end = size ( list ) if ( end . eq . 0 ) then ! empty array list = [ value ] elseif ( place . gt . 0. and . place . le . end ) then list ( place ) = value else ! put in middle of array write ( stderr , * ) '*replace_d* error: index out of range. end=' , end , ' index=' , place endif if ( debug ) write ( stderr , * ) '*replace_d* END VALUE=' , value , ' PLACE=' , place , ' NEWSIZE=' , size ( list ) end subroutine replace_d subroutine replace_r ( list , value , place ) ! ident_16=\"@(#) M_list replace_r(3fp) place value into allocatable array at specified position\" real , intent ( in ) :: value real , allocatable :: list (:) integer , intent ( in ) :: place integer :: end if ( debug ) write ( stderr , * ) '*replace_r* START REPLACE_R VALUE=' , value , ' PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if (. not . allocated ( list )) then list = [ real :: ] endif end = size ( list ) if ( end . eq . 0 ) then ! empty array list = [ value ] elseif ( place . gt . 0. and . place . le . end ) then list ( place ) = value else ! put in middle of array write ( stderr , * ) '*replace_r* error: index out of range. end=' , end , ' index=' , place endif if ( debug ) write ( stderr , * ) '*replace_r* END REPLACE_R VALUE=' , value , ' PLACE=' , place , ' NEWSIZE=' , size ( list ) end subroutine replace_r subroutine replace_l ( list , value , place ) ! ident_17=\"@(#) M_list replace_l(3fp) place value into allocatable array at specified position\" logical , allocatable :: list (:) logical , intent ( in ) :: value integer , intent ( in ) :: place integer :: end if (. not . allocated ( list )) then list = [ logical :: ] endif end = size ( list ) if ( debug ) write ( stderr , * ) '*replace_l* START REPLACE_L VALUE=' , value , ' PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if ( end . eq . 0 ) then ! empty array list = [ value ] elseif ( place . gt . 0. and . place . le . end ) then list ( place ) = value else ! put in middle of array write ( stderr , * ) '*replace_l* error: index out of range. end=' , end , ' index=' , place endif if ( debug ) write ( stderr , * ) '*replace_l* END REPLACE_L VALUE=' , value , ' PLACE=' , place , ' NEWSIZE=' , size ( list ) end subroutine replace_l subroutine replace_i ( list , value , place ) ! ident_18=\"@(#) M_list replace_i(3fp) place value into allocatable array at specified position\" integer , intent ( in ) :: value integer , allocatable :: list (:) integer , intent ( in ) :: place integer :: end if (. not . allocated ( list )) then list = [ integer :: ] endif end = size ( list ) if ( debug ) write ( stderr , * ) '*replace_i* START VALUE=' , value , ' PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if ( end . eq . 0 ) then ! empty array list = [ value ] elseif ( place . gt . 0. and . place . le . end ) then list ( place ) = value else ! put in middle of array write ( stderr , * ) '*replace_i* error: index out of range. end=' , end , ' index=' , place endif if ( debug ) write ( stderr , * ) '*replace_i* END VALUE=' , value , ' PLACE=' , place , ' NEWSIZE=' , size ( list ) end subroutine replace_i !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    insert(3f) - [M_list] insert entry into a string array at specified position !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!   subroutine insert(list,value,place) !! !!    character(len=*)|doubleprecision|real|integer,intent(in) :: value !!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:) !!    integer,intent(in)    :: place !! !!##DESCRIPTION !! !!    Insert a value into an allocatable array at the specified index. !!    The list and value must be of the same type (CHARACTER, DOUBLEPRECISION, !!    REAL, or INTEGER) !! !!##OPTIONS !! !!    list    is the list array. Must be sorted in descending order. !!    value   the value to place in the array !!    PLACE   is the subscript that the entry should be placed at !! !!##EXAMPLES !! !!   Find if a string is in a sorted array, and insert the string into !!   the list if it is not present ... !! !!     program demo_insert !!     use M_sort, only : sort_shell !!     use M_list, only : locate, insert !!     implicit none !!     character(len=:),allocatable :: arr(:) !!     integer                       :: i !! !!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ] !!     ! make sure sorted in descending order !!     call sort_shell(arr,order='d') !!     ! add or replace values !!     call update(arr,'b') !!     call update(arr,'[') !!     call update(arr,'c') !!     call update(arr,'ZZ') !!     call update(arr,'ZZZ') !!     call update(arr,'ZZZZ') !!     call update(arr,'') !!     call update(arr,'z') !! !!     contains !!     subroutine update(arr,string) !!     character(len=:),allocatable :: arr(:) !!     character(len=*)             :: string !!     integer                      :: place, end !! !!     end=size(arr) !!     ! find where string is or should be !!     call locate(arr,string,place) !!     ! if string was not found insert it !!     if(place.lt.1)then !!        call insert(arr,string,abs(place)) !!     endif !!     ! show array !!     end=size(arr) !!     write(*,'(\"array is now SIZE=\",i0,1x,*(a,\",\"))')end,(trim(arr(i)),i=1,end) !! !!     end subroutine update !!     end program demo_insert !! !!   Results !! !!        > array is now SIZE=5 xxx,b,aaa,ZZZ,, !!        > array is now SIZE=6 xxx,b,aaa,[,ZZZ,, !!        > array is now SIZE=7 xxx,c,b,aaa,[,ZZZ,, !!        > array is now SIZE=8 xxx,c,b,aaa,[,ZZZ,ZZ,, !!        > array is now SIZE=9 xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,, !!        > array is now SIZE=10 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,, !! !!##AUTHOR !!    1989,2017 John S. Urban !!##LICENSE !!    Public Domain subroutine insert_c ( list , value , place ) ! ident_19=\"@(#) M_list insert_c(3fp) place string into allocatable string array at specified position\" character ( len =* ), intent ( in ) :: value character ( len = :), allocatable :: list (:) integer , intent ( in ) :: place integer :: ii integer :: end if ( debug ) write ( stderr , * ) '*insert_c* START VALUE=' , trim ( value ), ' PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if (. not . allocated ( list )) then list = [ character ( len = max ( len_trim ( value ), 2 )) :: ] endif ii = max ( len_trim ( value ), len ( list ), 2 ) end = size ( list ) !call slower() call faster ( ii ) if ( debug ) write ( stderr , * ) '*insert_c* END VALUE=' , trim ( value ), ' PLACE=' , place , ' NEWSIZE=' , size ( list ) contains subroutine slower () character ( len = :), allocatable :: kludge (:) if ( end . eq . 0 ) then ! empty array list = [ character ( len = ii ) :: value ] elseif ( place . eq . 1 ) then ! put in front of array kludge = [ character ( len = ii ) :: value , list ] list = kludge elseif ( place . gt . end ) then ! put at end of array kludge = [ character ( len = ii ) :: list , value ] list = kludge elseif ( place . ge . 2. and . place . le . end ) then ! put in middle of array kludge = [ character ( len = ii ) :: list (: place - 1 ), value , list ( place :) ] list = kludge else ! index out of range write ( stderr , * ) '*insert_c* error: index out of range. end=' , end , ' index=' , place , ' value=' , value endif end subroutine slower subroutine faster ( ilen ) integer , intent ( in ) :: ilen character ( len = :), allocatable :: temp (:) allocate ( character ( len = ilen ) :: temp ( size ( list ) + 1 )) if ( end . eq . 0 ) then ! empty array temp (:) = [ character ( len = ii ) :: value ] elseif ( place . eq . 1 ) then ! put in front of array temp ( 1 ) = value temp ( 2 :) = list elseif ( place . gt . end ) then ! put at end of array temp ( 1 : end ) = list temp ( end + 1 ) = value elseif ( place . ge . 2. and . place . le . end ) then ! put in middle of array temp (: place - 1 ) = list (: place - 1 ) temp ( place ) = value temp ( place + 1 :) = list ( place :) else ! index out of range write ( stderr , * ) '*insert_c* error: index out of range. end=' , end , ' index=' , place , ' value=' , value endif call move_alloc ( from = temp , to = list ) end subroutine faster end subroutine insert_c subroutine insert_r ( list , value , place ) ! ident_20=\"@(#) M_list insert_r(3fp) place real value into allocatable array at specified position\" real , intent ( in ) :: value real , allocatable :: list (:) integer , intent ( in ) :: place integer :: end if ( debug ) write ( stderr , * ) '*insert_r* START VALUE=' , value , ' PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if (. not . allocated ( list )) then list = [ real :: ] endif end = size ( list ) if ( end . eq . 0 ) then ! empty array list = [ value ] elseif ( place . eq . 1 ) then ! put in front of array list = [ value , list ] elseif ( place . gt . end ) then ! put at end of array list = [ list , value ] elseif ( place . ge . 2. and . place . le . end ) then ! put in middle of array list = [ list (: place - 1 ), value , list ( place :) ] else ! index out of range write ( stderr , * ) '*insert_r* error: index out of range. end=' , end , ' index=' , place , ' value=' , value endif if ( debug ) write ( stderr , * ) '*insert_r* END VALUE=' , value , ' PLACE=' , place , ' NEWSIZE=' , size ( list ) end subroutine insert_r subroutine insert_d ( list , value , place ) ! ident_21=\"@(#) M_list insert_d(3fp) place doubleprecision value into allocatable array at specified position\" doubleprecision , intent ( in ) :: value doubleprecision , allocatable :: list (:) integer , intent ( in ) :: place integer :: end if ( debug ) write ( stderr , * ) '*insert_d* START VALUE=' , value , ' PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if (. not . allocated ( list )) then list = [ doubleprecision :: ] endif end = size ( list ) if ( end . eq . 0 ) then ! empty array list = [ value ] elseif ( place . eq . 1 ) then ! put in front of array list = [ value , list ] elseif ( place . gt . end ) then ! put at end of array list = [ list , value ] elseif ( place . ge . 2. and . place . le . end ) then ! put in middle of array list = [ list (: place - 1 ), value , list ( place :) ] else ! index out of range write ( stderr , * ) '*insert_d* error: index out of range. end=' , end , ' index=' , place , ' value=' , value endif if ( debug ) write ( stderr , * ) '*insert_d* END VALUE=' , value , ' PLACE=' , place , ' NEWSIZE=' , size ( list ) end subroutine insert_d subroutine insert_l ( list , value , place ) ! ident_22=\"@(#) M_list insert_l(3fp) place value into allocatable array at specified position\" logical , allocatable :: list (:) logical , intent ( in ) :: value integer , intent ( in ) :: place integer :: end if (. not . allocated ( list )) then list = [ logical :: ] endif end = size ( list ) if ( debug ) write ( stderr , * ) '*insert_l* START VALUE=' , value , ' PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if ( end . eq . 0 ) then ! empty array list = [ value ] elseif ( place . eq . 1 ) then ! put in front of array list = [ value , list ] elseif ( place . gt . end ) then ! put at end of array list = [ list , value ] elseif ( place . ge . 2. and . place . le . end ) then ! put in middle of array list = [ list (: place - 1 ), value , list ( place :) ] else ! index out of range write ( stderr , * ) '*insert_l* error: index out of range. end=' , end , ' index=' , place , ' value=' , value endif if ( debug ) write ( stderr , * ) '*insert_l* END VALUE=' , value , ' PLACE=' , place , ' NEWSIZE=' , size ( list ) end subroutine insert_l subroutine insert_i ( list , value , place ) ! ident_23=\"@(#) M_list insert_i(3fp) place value into allocatable array at specified position\" integer , allocatable :: list (:) integer , intent ( in ) :: value integer , intent ( in ) :: place integer :: end if (. not . allocated ( list )) then list = [ integer :: ] endif end = size ( list ) if ( debug ) write ( stderr , * ) '*insert_i* START VALUE=' , value , ' PLACE=' , place , ' ORIGINALSIZE=' , size ( list ) if ( end . eq . 0 ) then ! empty array list = [ value ] elseif ( place . eq . 1 ) then ! put in front of array list = [ value , list ] elseif ( place . gt . end ) then ! put at end of array list = [ list , value ] elseif ( place . ge . 2. and . place . le . end ) then ! put in middle of array list = [ list (: place - 1 ), value , list ( place :) ] else ! index out of range write ( stderr , * ) '*insert_i* error: index out of range. end=' , end , ' index=' , place , ' value=' , value endif if ( debug ) write ( stderr , * ) '*insert_i* END VALUE=' , value , ' PLACE=' , place , ' NEWSIZE=' , size ( list ) end subroutine insert_i !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    del(3f) - [M_list::dictionary::OOPS] delete entry by key name from !!              a basic dictionary !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!   type(dictionary) :: dict !! !!    character(len=*),intent(in) :: key !! !!    dict%del(key) !! !!##DESCRIPTION !! !!    Delete an entry from a basic dictionary if it is present. !! !!##OPTIONS !! !!    DICT   the dictionary. !!    KEY    the key name to find and delete from the dictionary. !! !!##EXAMPLES !! !!   Delete an entry from a dictionary by key name. !! !!     program demo_del !!     use M_list, only : dictionary !!     implicit none !!     type(dictionary) :: caps !!     integer                       :: i !!        ! create a character string dictionary !!        call caps%set('A','aye') !!        call caps%set('B','bee') !!        call caps%set('C','see') !!        call caps%set('D','dee') !!        ! show current dictionary !!        write(*,101)(trim(caps%key(i)),trim(caps%value(i)),i=1,size(caps%key)) !!        ! delete dictionary entries !!        call  caps%del('A') !!        call  caps%del('C') !!        call  caps%del('z') ! a noop as there is no key of 'z' !!        ! show current dictionary !!        write(*,101)(trim(caps%key(i)),trim(caps%value(i)),i=1,size(caps%key)) !! !!     101 format (1x,*(a,\"='\",a,\"'\",:,\",\")) !!     end program demo_del !! !!   Results !! !!        > D='dee',C='see',B='bee',A='aye' !!        > D='dee',B='bee' !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine dict_delete ( self , key ) ! ident_24=\"@(#) M_list dict_delete(3f) remove string from sorted allocatable string array if present\" class ( dictionary ), intent ( in ) :: self character ( len =* ), intent ( in ) :: key integer :: place call locate ( self % key , key , place ) if ( place . ge . 1 ) then call remove ( self % key , place ) call remove ( self % value , place ) call remove ( self % count , place ) endif end subroutine dict_delete !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    get(3f) - [M_list::dictionary::OOPS] get value of key-value pair in !!              a dictionary given key !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!   type(dictionary) :: dict !! !!    character(len=*),intent(in) :: key !!    character(len=*),intent(in) :: VALUE !! !!    value=dict%get(key) !! !! !!##DESCRIPTION !! !!    get a value given a key from a key-value dictionary !! !!    If key is not found in dictionary , return a blank !! !!##OPTIONS !! !!    DICT     is the dictionary. !!    KEY      key name !!    VALUE    value associated with key !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_get !!     use M_list, only : dictionary !!     implicit none !!     type(dictionary)             :: table !!     character(len=:),allocatable :: val !!     integer                      :: i !! !!        call table%set('A','value for A') !!        call table%set('B','value for B') !!        call table%set('C','value for C') !!        call table%set('D','value for D') !!        call table%set('E','value for E') !!        call table%set('F','value for F') !!        call table%set('G','value for G') !! !!        write(*,*)'A=',table%get('A') !!        write(*,*)'B=',table%get('B') !!        write(*,*)'C=',table%get('C') !!        write(*,*)'D=',table%get('D') !!        write(*,*)'E=',table%get('E') !!        write(*,*)'F=',table%get('F') !!        write(*,*)'G=',table%get('G') !!        write(*,*)'H=',table%get('H') !! !!      end program demo_get !! !!   Results !! !!       >  A=value for A !!       >  B=value for B !!       >  C=value for C !!       >  D=value for D !!       >  E=value for E !!       >  F=value for F !!       >  G=value for G !!       >  H= !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain function dict_get ( self , key ) result ( value ) ! ident_25=\"@(#) M_list dict_get(3f) get value of key-value pair in dictionary given key\" class ( dictionary ), intent ( in ) :: self character ( len =* ), intent ( in ) :: key character ( len = :), allocatable :: value integer :: place call locate ( self % key , key , place ) if ( place . lt . 1 ) then value = '' else value = self % value ( place )(: self % count ( place )) endif end function dict_get !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    set(3f) - [M_list::dictionary::OOPS] add or replace a key-value pair !!              in a dictionary !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!   type(dictionary) :: dict !! !!    character(len=*),intent(in) :: key !!    character(len=*),intent(in) :: VALUE !! !!    call dict%rep(key,value) !! !!##DESCRIPTION !!    Add or replace a key-value pair in a dictionary. !! !!##OPTIONS !!    DICT     is the dictionary. !!    key      key name !!    VALUE    value associated with key !! !!##EXAMPLES !! !!   Add or replace a key and value pair in a dictionary !! !!     program demo_set !!     use M_list, only : dictionary !!     implicit none !!     type(dictionary) :: dict !!     integer          :: i !! !!         call dict%set('A','b') !!         call dict%set('B','&#94;') !!         call dict%set('C',' ') !!         call dict%set('D','c') !!         call dict%set('E','ZZ') !!         call dict%set('F','ZZZZ') !!         call dict%set('G','z') !!         call dict%set('A','new value for A') !! !!         write(*,'(*(a,\"==>\",\"[\",a,\"]\",/))') & !!          & (trim(dict%key(i)),              & !!          & dict%value(i)(:dict%count(i)),   & !!          & i=1,size(dict%key)) !! !!      end program demo_set !! !!   Results !! !!       > G==>[z] !!       > F==>[ZZZZ] !!       > E==>[ZZ] !!       > D==>[c] !!       > C==>[] !!       > B==>[&#94;] !!       > A==>[new value for A] !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine dict_add ( self , key , value ) ! ident_26=\"@(#) M_list dict_add(3f) place key-value pair into dictionary adding the key if required\" class ( dictionary ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ) :: value integer :: place integer :: place2 call locate ( self % key , key , place ) if ( place . le . 0 ) then place2 = iabs ( place ) call insert ( self % key , key , place2 ) call insert ( self % value , value , place2 ) call insert ( self % count , len_trim ( value ), place2 ) elseif ( place . gt . 0 ) then ! replace instead of insert call replace ( self % value , value , place ) call replace ( self % count , len_trim ( value ), place ) endif end subroutine dict_add !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    clr(3f) - [M_list::dictionary::OOPS] clear basic dictionary !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!   type(dictionary) :: dict !! !!    call dict%clr() !! !!##DESCRIPTION !! !!    clear a basic dictionary. !! !!##OPTIONS !! !!    DICT   the dictionary. !! !!##EXAMPLES !! !!   create and clear a basic dictionary !! !!     program demo_clr !!     use M_list, only : dictionary !!     implicit none !!     type(dictionary) :: caps !!     integer                       :: i !!        ! create a character string dictionary !!        call caps%set('A','aye') !!        call caps%set('B','bee') !!        call caps%set('C','see') !!        call caps%set('D','dee') !!        ! show current dictionary !!        write(*,'(\"DICTIONARY BEFORE CLEARED\")') !!        write(*,101)(trim(caps%key(i)),trim(caps%value(i)),i=1,size(caps%key)) !!        call  caps%clr() !!        write(*,'(\"DICTIONARY AFTER CLEARED\")') !!        ! show current dictionary !!        write(*,101)(trim(caps%key(i)),trim(caps%value(i)),i=1,size(caps%key)) !! !!     101 format (1x,*(a,\"='\",a,\"'\",:,\",\")) !!     end program demo_clr !! !!   Results !! !!       > DICTIONARY BEFORE CLEARED !!       >  D='dee',C='see',B='bee',A='aye' !!       > DICTIONARY AFTER CLEARED !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine dict_clear ( self ) ! ident_27=\"@(#) M_list dict_clear(3f) clear basic dictionary\" class ( dictionary ), intent ( inout ) :: self integer :: i do i = size ( self % key ), 1 , - 1 call self % del ( self % key ( i )) enddo end subroutine dict_clear !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    ifdef(3f) - [M_list::dictionary::OOPS] return whether name is present !!                in dictionary or not !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!   type(dictionary) :: dict !! !!    character(len=*),intent(in) :: key !!    logical :: value !! !!    value=dict%ifdef(key) !! !! !!##DESCRIPTION !! !!    determine if name is already defined in dictionary or not !! !!##OPTIONS !! !!    DICT     is the dictionary. !!    KEY      key name !! !!##RETURNS !!    VALUE    .FALSE. if name not defined, .TRUE if name is defined. !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_ifdef !!     use M_list, only : dictionary !!     implicit none !!     type(dictionary)             :: table !!     character(len=:),allocatable :: val !!     integer                      :: i !! !!        call table%set('A','value for A') !!        call table%set('B','value for B') !!        call table%set('C','value for C') !!        call table%set('D','value for D') !!        call table%set('E','value for E') !!        call table%set('F','value for F') !!        call table%set('G','value for G') !!        call table%del('F') !!        call table%del('D') !! !!        write(*,*)'A=',table%ifdef('A') !!        write(*,*)'B=',table%ifdef('B') !!        write(*,*)'C=',table%ifdef('C') !!        write(*,*)'D=',table%ifdef('D') !!        write(*,*)'E=',table%ifdef('E') !!        write(*,*)'F=',table%ifdef('F') !!        write(*,*)'G=',table%ifdef('G') !!        write(*,*)'H=',table%ifdef('H') !! !!      end program demo_ifdef !! !!   Results: !! !!     > A= T !!     > B= T !!     > C= T !!     > D= F !!     > E= T !!     > F= F !!     > G= T !!     > H= F !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain function dict_ifdef ( self , key ) result ( value ) ! ident_28=\"@(#) M_list dict_ifdef(3f) return whether name is defined or not\" class ( dictionary ), intent ( in ) :: self character ( len =* ), intent ( in ) :: key logical :: value integer :: place call locate ( self % key , key , place ) if ( place . lt . 1 ) then value = . false . else value = . true . endif end function dict_ifdef !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== end module M_list !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !===================================================================================================================================","tags":"","loc":"sourcefile/m_list.f90.html"},{"title":"demo_clr.f90 – M_list","text":"Contents Programs demo_clr Source Code demo_clr.f90 Source Code program demo_clr use M_list , only : dictionary implicit none type ( dictionary ) :: caps integer :: i ! create a character string dictionary call caps % set ( 'A' , 'aye' ) call caps % set ( 'B' , 'bee' ) call caps % set ( 'C' , 'see' ) call caps % set ( 'D' , 'dee' ) ! show current dictionary write ( * , '(\"DICTIONARY BEFORE CLEARED\")' ) write ( * , 101 )( trim ( caps % key ( i )), trim ( caps % value ( i )), i = 1 , size ( caps % key )) call caps % clr () write ( * , '(\"DICTIONARY AFTER CLEARED\")' ) ! show current dictionary write ( * , 101 )( trim ( caps % key ( i )), trim ( caps % value ( i )), i = 1 , size ( caps % key )) 101 format ( 1 x , * ( a , \"='\" , a , \"'\" ,:, \",\" )) end program demo_clr","tags":"","loc":"sourcefile/demo_clr.f90.html"},{"title":"demo_locate.f90 – M_list","text":"Contents Programs demo_locate Source Code demo_locate.f90 Source Code program demo_locate use M_sort , only : sort_shell use M_list , only : locate implicit none character ( len = :), allocatable :: arr (:) integer :: i arr = [ character ( len = 20 ) :: '' , 'ZZZ' , 'aaa' , 'b' , 'xxx' ] ! make sure sorted in descending order call sort_shell ( arr , order = 'd' ) call update ( arr , 'b' ) call update ( arr , '[' ) call update ( arr , 'c' ) call update ( arr , 'ZZ' ) call update ( arr , 'ZZZZ' ) call update ( arr , 'z' ) contains subroutine update ( arr , string ) character ( len = :), allocatable :: arr (:) character ( len =* ) :: string integer :: place , plus , ii , end ! find where string is or should be call locate ( arr , string , place ) write ( * , * ) 'for \"' // string // '\" index is ' , place , size ( arr ) ! if string was not found insert it if ( place . lt . 1 ) then plus = abs ( place ) ii = len ( arr ) end = size ( arr ) ! empty array if ( end . eq . 0 ) then arr = [ character ( len = ii ) :: string ] ! put in front of array elseif ( plus . eq . 1 ) then arr = [ character ( len = ii ) :: string , arr ] ! put at end of array elseif ( plus . eq . end ) then arr = [ character ( len = ii ) :: arr , string ] ! put in middle of array else arr = [ character ( len = ii ) :: arr (: plus - 1 ), string , arr ( plus :) ] endif ! show array write ( * , '(\"SIZE=\",i0,1x,*(a,\",\"))' ) end ,( trim ( arr ( i )), i = 1 , end ) endif end subroutine update end program demo_locate","tags":"","loc":"sourcefile/demo_locate.f90.html"},{"title":"demo_replace.f90 – M_list","text":"Contents Programs demo_replace Source Code demo_replace.f90 Source Code program demo_replace use M_list , only : insert , locate , replace ! Find if a key is in a list and insert it ! into the key list and value list if it is not present ! or replace the associated value if the key existed implicit none character ( len = 20 ) :: key character ( len = 100 ) :: val character ( len = :), allocatable :: keywords (:) character ( len = :), allocatable :: values (:) integer :: i integer :: place call update ( 'b' , 'value of b' ) call update ( 'a' , 'value of a' ) call update ( 'c' , 'value of c' ) call update ( 'c' , 'value of c again' ) call update ( 'd' , 'value of d' ) call update ( 'a' , 'value of a again' ) ! show array write ( * , '(*(a,\"==>\",a,/))' )& &( trim ( keywords ( i )), trim ( values ( i )), i = 1 , size ( keywords )) call locate ( keywords , 'a' , place ) if ( place . gt . 0 ) then write ( * , * ) 'The value of \"a\" is ' , trim ( values ( place )) else write ( * , * ) '\"a\" not found' endif contains subroutine update ( key , val ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ) :: val integer :: place ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , abs ( place )) call insert ( values , val , abs ( place )) else ! replace call replace ( values , val , place ) endif end subroutine update end program demo_replace","tags":"","loc":"sourcefile/demo_replace.f90.html"},{"title":"demo_remove.f90 – M_list","text":"Contents Programs demo_remove Source Code demo_remove.f90 Source Code program demo_remove use M_sort , only : sort_shell use M_list , only : locate , remove implicit none character ( len = :), allocatable :: arr (:) integer :: i integer :: end arr = [ character ( len = 20 ) :: '' , 'ZZZ' , 'Z' , 'aaa' , 'b' , 'b' , 'ab' , 'bb' , 'xxx' ] ! make sure sorted in descending order call sort_shell ( arr , order = 'd' ) end = size ( arr ) write ( * , '(\"SIZE=\",i0,1x,*(a,\",\"))' ) end ,( trim ( arr ( i )), i = 1 , end ) call remove ( arr , 1 ) end = size ( arr ) write ( * , '(\"SIZE=\",i0,1x,*(a,\",\"))' ) end ,( trim ( arr ( i )), i = 1 , end ) call remove ( arr , 4 ) end = size ( arr ) write ( * , '(\"SIZE=\",i0,1x,*(a,\",\"))' ) end ,( trim ( arr ( i )), i = 1 , end ) end program demo_remove","tags":"","loc":"sourcefile/demo_remove.f90.html"},{"title":"demo_M_list.f90 – M_list","text":"Contents Programs demo_M_list Source Code demo_M_list.f90 Source Code program demo_M_list use M_list , only : insert , locate , replace , remove ! create a dictionary with character keywords, values, and value lengths ! using the routines for maintaining a list use M_list , only : locate , insert , replace implicit none character ( len = :), allocatable :: keywords (:) character ( len = :), allocatable :: values (:) integer , allocatable :: counts (:) integer :: i ! insert and replace entries call update ( 'b' , 'value of b' ) call update ( 'a' , 'value of a' ) call update ( 'c' , 'value of c' ) call update ( 'c' , 'value of c again' ) call update ( 'd' , 'value of d' ) call update ( 'a' , 'value of a again' ) ! show array write ( * , '(*(a,\"==>\",\"[\",a,\"]\",/))' )& & ( trim ( keywords ( i )), values ( i )(: counts ( i )), i = 1 , size ( keywords )) ! remove some entries call update ( 'a' ) call update ( 'c' ) write ( * , '(*(a,\"==>\",\"[\",a,\"]\",/))' )& & ( trim ( keywords ( i )), values ( i )(: counts ( i )), i = 1 , size ( keywords )) ! get some values write ( * , * ) 'get b=>' , get ( 'b' ) write ( * , * ) 'get d=>' , get ( 'd' ) write ( * , * ) 'get notthere=>' , get ( 'notthere' ) ! contains subroutine update ( key , valin ) character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( in ), optional :: valin integer :: place integer :: ilen character ( len = :), allocatable :: val if ( present ( valin )) then val = valin ilen = len_trim ( val ) ! find where string is or should be call locate ( keywords , key , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( keywords , key , iabs ( place )) call insert ( values , val , iabs ( place )) call insert ( counts , ilen , iabs ( place )) else call replace ( values , val , place ) call replace ( counts , ilen , place ) endif else call locate ( keywords , key , place ) if ( place . gt . 0 ) then call remove ( keywords , place ) call remove ( values , place ) call remove ( counts , place ) endif endif end subroutine update function get ( key ) result ( valout ) character ( len =* ), intent ( in ) :: key character ( len = :), allocatable :: valout integer :: place ! find where string is or should be call locate ( keywords , key , place ) if ( place . lt . 1 ) then valout = '' else valout = values ( place )(: counts ( place )) endif end function get end program demo_M_list","tags":"","loc":"sourcefile/demo_m_list.f90.html"},{"title":"demo_dictionary.f90 – M_list","text":"Contents Programs test_dictionary Source Code demo_dictionary.f90 Source Code program test_dictionary use M_list , only : dictionary implicit none type ( dictionary ) :: table ! ! create a character string dictionary ! call table % set ( 'A' , 'aye' ) call table % set ( 'B' , 'bee' ) call table % set ( 'C' , 'see' ) call table % set ( 'D' , 'dee' ) ! write ( * , * ) 'A=' , table % get ( 'A' ) write ( * , * ) 'C=' , table % get ( 'C' ) write ( * , * ) 'notthere=' , table % get ( 'notthere' ) ! call print_dict () ! ! delete dictionary entries ! call table % del ( 'A' ) call table % del ( 'C' ) call table % del ( 'z' ) ! a noop as there is no key of 'z' ! call print_dict () ! ! clear dictionary ! call table % clr () ! call print_dict () ! contains ! subroutine print_dict () integer :: i ! the dictionary is just three arrays write ( * , '(\"DICTIONARY:\")' ) write ( * , '(*(a,\"==>\",\"[\",a,\"]\",/))' ) & & ( trim ( table % key ( i )), & & table % value ( i )(: table % count ( i )), & & i = 1 , size ( table % key )) ! end subroutine print_dict ! end program test_dictionary","tags":"","loc":"sourcefile/demo_dictionary.f90.html"},{"title":"demo_insert.f90 – M_list","text":"Contents Programs demo_insert Source Code demo_insert.f90 Source Code program demo_insert use M_sort , only : sort_shell use M_list , only : locate , insert implicit none character ( len = :), allocatable :: arr (:) integer :: i arr = [ character ( len = 20 ) :: '' , 'ZZZ' , 'aaa' , 'b' , 'xxx' ] ! make sure sorted in descending order call sort_shell ( arr , order = 'd' ) ! add or replace values call update ( arr , 'b' ) call update ( arr , '[' ) call update ( arr , 'c' ) call update ( arr , 'ZZ' ) call update ( arr , 'ZZZ' ) call update ( arr , 'ZZZZ' ) call update ( arr , '' ) call update ( arr , 'z' ) contains subroutine update ( arr , string ) character ( len = :), allocatable :: arr (:) character ( len =* ) :: string integer :: place , end end = size ( arr ) ! find where string is or should be call locate ( arr , string , place ) ! if string was not found insert it if ( place . lt . 1 ) then call insert ( arr , string , abs ( place )) endif ! show array end = size ( arr ) write ( * , '(\"array is now SIZE=\",i0,1x,*(a,\",\"))' ) end ,( trim ( arr ( i )), i = 1 , end ) end subroutine update end program demo_insert","tags":"","loc":"sourcefile/demo_insert.f90.html"},{"title":"demo_set.f90 – M_list","text":"Contents Programs demo_set Source Code demo_set.f90 Source Code program demo_set use M_list , only : dictionary implicit none type ( dictionary ) :: dict integer :: i call dict % set ( 'A' , 'b' ) call dict % set ( 'B' , '&#94;' ) call dict % set ( 'C' , ' ' ) call dict % set ( 'D' , 'c' ) call dict % set ( 'E' , 'ZZ' ) call dict % set ( 'F' , 'ZZZZ' ) call dict % set ( 'G' , 'z' ) call dict % set ( 'A' , 'new value for A' ) write ( * , '(*(a,\"==>\",\"[\",a,\"]\",/))' ) & & ( trim ( dict % key ( i )), & & dict % value ( i )(: dict % count ( i )), & & i = 1 , size ( dict % key )) end program demo_set","tags":"","loc":"sourcefile/demo_set.f90.html"},{"title":"demo_del.f90 – M_list","text":"Contents Programs demo_del Source Code demo_del.f90 Source Code program demo_del use M_list , only : dictionary implicit none type ( dictionary ) :: caps integer :: i ! create a character string dictionary call caps % set ( 'A' , 'aye' ) call caps % set ( 'B' , 'bee' ) call caps % set ( 'C' , 'see' ) call caps % set ( 'D' , 'dee' ) ! show current dictionary write ( * , 101 )( trim ( caps % key ( i )), trim ( caps % value ( i )), i = 1 , size ( caps % key )) ! delete dictionary entries call caps % del ( 'A' ) call caps % del ( 'C' ) call caps % del ( 'z' ) ! a noop as there is no key of 'z' ! show current dictionary write ( * , 101 )( trim ( caps % key ( i )), trim ( caps % value ( i )), i = 1 , size ( caps % key )) 101 format ( 1 x , * ( a , \"='\" , a , \"'\" ,:, \",\" )) end program demo_del","tags":"","loc":"sourcefile/demo_del.f90.html"},{"title":"demo_ifdef.f90 – M_list","text":"Contents Programs demo_ifdef Source Code demo_ifdef.f90 Source Code program demo_ifdef use M_list , only : dictionary implicit none type ( dictionary ) :: table character ( len = :), allocatable :: val integer :: i call table % set ( 'A' , 'value for A' ) call table % set ( 'B' , 'value for B' ) call table % set ( 'C' , 'value for C' ) call table % set ( 'D' , 'value for D' ) call table % set ( 'E' , 'value for E' ) call table % set ( 'F' , 'value for F' ) call table % set ( 'G' , 'value for G' ) call table % del ( 'F' ) call table % del ( 'D' ) write ( * , * ) 'A=' , table % ifdef ( 'A' ) write ( * , * ) 'B=' , table % ifdef ( 'B' ) write ( * , * ) 'C=' , table % ifdef ( 'C' ) write ( * , * ) 'D=' , table % ifdef ( 'D' ) write ( * , * ) 'E=' , table % ifdef ( 'E' ) write ( * , * ) 'F=' , table % ifdef ( 'F' ) write ( * , * ) 'G=' , table % ifdef ( 'G' ) write ( * , * ) 'H=' , table % ifdef ( 'H' ) end program demo_ifdef","tags":"","loc":"sourcefile/demo_ifdef.f90.html"},{"title":"demo_get.f90 – M_list","text":"Contents Programs demo_get Source Code demo_get.f90 Source Code program demo_get use M_list , only : dictionary implicit none type ( dictionary ) :: table character ( len = :), allocatable :: val integer :: i call table % set ( 'A' , 'value for A' ) call table % set ( 'B' , 'value for B' ) call table % set ( 'C' , 'value for C' ) call table % set ( 'D' , 'value for D' ) call table % set ( 'E' , 'value for E' ) call table % set ( 'F' , 'value for F' ) call table % set ( 'G' , 'value for G' ) write ( * , * ) 'A=' , table % get ( 'A' ) write ( * , * ) 'B=' , table % get ( 'B' ) write ( * , * ) 'C=' , table % get ( 'C' ) write ( * , * ) 'D=' , table % get ( 'D' ) write ( * , * ) 'E=' , table % get ( 'E' ) write ( * , * ) 'F=' , table % get ( 'F' ) write ( * , * ) 'G=' , table % get ( 'G' ) write ( * , * ) 'H=' , table % get ( 'H' ) end program demo_get","tags":"","loc":"sourcefile/demo_get.f90.html"},{"title":"test_suite_M_list.f90 – M_list","text":"Contents Programs runtest Subroutines test_suite_M_list Source Code test_suite_M_list.f90 Source Code program runtest use M_framework , only : unit_test_stop interface ; subroutine test_suite_M_list (); end ; end interface call test_suite_M_list () call unit_test_stop () end program runtest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_suite_M_list use M_sort , only : sort_shell use M_framework__verify , only : unit_test , unit_test_start , unit_test_end use M_list , only : locate , insert , remove , replace , dictionary character ( len =* ), parameter :: share = ' -library libGPF -filename `pwd`/M_list.FF -documentation y -ufpp y -ccall n -archive GPF.a' integer :: place logical :: matched ! list call test_locate () ! finds the index where a string is found or should be in a sorted array call test_insert () ! insert entry into a string array at specified position call test_remove () ! remove entry from an allocatable array at specified position call test_replace () ! replace entry in a string array at specified position ! dictionary call test_dict_set () ! add or replace a key-value pair in a dictionary call test_dict_delete () ! delete entry by key name from a basic dictionary call test_dict_get () ! value of key-value pair in a dictionary given key call test_dict_ifdef () ! return whether name is present in dictionary or not call test_dict_clr () ! clear basic dictionary ! contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dict_set type ( dictionary ) :: dict call unit_test_start ( 'dict%set' , 'add string into allocatable string array by name' , opts = share , matched = matched ) if (. not . matched ) return call dict % set ( 'A' , 'value for a' ) call unit_test ( 'dict%set' , all ( dict % key . eq .[ character ( len = 20 ) :: 'A' ]), msg = 'array should be A' ) call dict % set ( 'b' , 'value for b' ) call dict % set ( 'c' , 'value for c' ) call dict % set ( 'z' , 'value for z' ) call unit_test ( 'dict%set' , all ( dict % key . eq .[ character ( len = 20 ) :: 'z' , 'c' , 'b' , 'A' ]), 'array should be z c b A' ) call dict % set ( 'ZZ' , 'value for ZZ' ) call dict % set ( 'NOT' , 'not this one' ) call dict % set ( 'ZZZ' , 'value for ZZZ' ) call dict % set ( 'Z' , 'value for Z' ) call unit_test ( 'dict%set' , all ( dict % key . eq .[ character ( len = 20 ) :: 'z' , 'c' , 'b' , 'ZZZ' , 'ZZ' , 'Z' , 'NOT' , 'A' ]), 'strings ok' ) call unit_test_end ( 'dict%set' ) end subroutine test_dict_set !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dict_delete type ( dictionary ) :: dict call unit_test_start ( 'dict%del' , 'delete string by name from allocatable string array' , opts = share , matched = matched ) if (. not . matched ) return call dict % set ( 'A' , 'some A' ) call dict % set ( 'a' , 'some a' ) call dict % set ( 'b' , 'some b' ) call dict % set ( 'ZZ' , 'some ZZ' ) call dict % set ( 'ZZZ' , 'some ZZZ' ) call dict % set ( 'ZZ' , 'some ZZ' ) call dict % set ( 'Z' , 'some Z' ) call dict % set ( 'z' , 'some z' ) call dict % set ( 'c' , 'some c' ) !write(*,'(\"built \",a)')dict%key call dict % del ( 'A' ) call dict % del ( 'Z' ) call dict % del ( 'X' ) call dict % del ( 'ZZZ' ) call dict % del ( 'ZZ' ) call dict % del ( 'z' ) !write(*,'(\"remaining \",a)')dict%key call unit_test ( 'dict%del' , all ( dict % key . eq .[ character ( len = 20 ) :: 'c' , 'b' , 'a' ]), 'string deletes keys' ) !write(*,'(\"remaining key \",a)')dict%key !write(*,'(\"remaining val \",a)')dict%value call unit_test ( 'dict%del' , all ( dict % value . eq .[ character ( len = 20 ) :: 'some c' , 'some b' , 'some a' ]), 'string deletes values' ) call unit_test_end ( 'dict%del' ) end subroutine test_dict_delete !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dict_ifdef type ( dictionary ) :: tt logical , allocatable :: answers (:) call unit_test_start ( 'dict%ifdef' , 'return whether name is present in dictionary or not' , opts = share , matched = matched ) if (. not . matched ) return call tt % set ( 'A' , 'value for A' ) call tt % set ( 'B' , 'value for B' ) call tt % set ( 'C' , 'value for C' ) call tt % set ( 'D' , 'value for D' ) call tt % set ( 'E' , 'value for E' ) call tt % set ( 'F' , 'value for F' ) call tt % set ( 'G' , 'value for G' ) call tt % del ( 'F' ) call tt % del ( 'D' ) answers = [ tt % ifdef ( 'A' ), tt % ifdef ( 'B' ), tt % ifdef ( 'C' ), tt % ifdef ( 'D' ), tt % ifdef ( 'E' ), tt % ifdef ( 'F' ), tt % ifdef ( 'G' ), tt % ifdef ( 'H' )] call unit_test ( 'dict%' , all ( answers . eqv . [. true ., . true ., . true ., . false ., . true ., . false ., . true ., . false .]), 'ifdef tests' ) call unit_test_end ( 'dict%ifdef' ) end subroutine test_dict_ifdef !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dict_clr type ( dictionary ) :: tt logical , allocatable :: answers (:) call unit_test_start ( 'dict%ifdef' , 'return whether name is present in dictionary or not' , opts = share , matched = matched ) if (. not . matched ) return call tt % set ( 'A' , 'value for A' ) call tt % set ( 'B' , 'value for B' ) call tt % set ( 'C' , 'value for C' ) call tt % set ( 'D' , 'value for D' ) call tt % set ( 'E' , 'value for E' ) call tt % set ( 'F' , 'value for F' ) call tt % set ( 'G' , 'value for G' ) call tt % del ( 'F' ) call tt % del ( 'D' ) call tt % clr () answers = [ tt % ifdef ( 'A' ), tt % ifdef ( 'B' ), tt % ifdef ( 'C' ), tt % ifdef ( 'D' ), tt % ifdef ( 'E' ), tt % ifdef ( 'F' ), tt % ifdef ( 'G' ), tt % ifdef ( 'H' )] call unit_test ( 'dict%' , all ( answers . eqv . [. false ., . false ., . false ., . false ., . false ., . false ., . false ., . false .]), 'clr tests' ) call unit_test_end ( 'dict%clr' ) end subroutine test_dict_clr !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dict_get type ( dictionary ) :: dict character ( len = 20 ), allocatable :: val (:) call unit_test_start ( 'dict%get' , 'locate and get value by key name from dictionary' , opts = share , matched = matched ) if (. not . matched ) return call dict % set ( 'A' , 'some A' ) call dict % set ( 'Z' , 'some Z' ) call dict % set ( 'X' , 'some X' ) val = [ dict % get ( 'Z' ), dict % get ( 'A' ), dict % get ( 'X' )] !write(*,'(\"remaining \",a)')dict%key call unit_test ( 'dict%get' , all ( dict % key . eq .[ character ( len = 20 ) :: 'Z' , 'X' , 'A' ]), 'string get keys' ) call unit_test ( 'dict%get' , all ( dict % value . eq .[ character ( len = 20 ) :: 'some Z' , 'some X' , 'some A' ]), 'string get values ' ) call unit_test_end ( 'dict%get' ) end subroutine test_dict_get !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_locate character ( len = :), allocatable :: lst (:) lst = [ character ( len = 20 ) :: '' , 'ZZZ' , 'aaa' , 'b' , 'xxx' ] ! make sure sorted in descending order call sort_shell ( lst , order = 'd' ) call unit_test_start ( 'locate' , 'locate string in allocatable string array sorted in descending order' , opts = share , matched = matched ) if (. not . matched ) return call locate ( lst , 'ZZZ' , place ) call unit_test ( 'locate' , place . eq . 4 , 'ZZZ' , place , 'should be ' , 4 ) call locate ( lst , 'zqj' , place ) call unit_test ( 'locate' , place . eq . - 1 , 'zqj' , place , 'should be ' , - 1 ) call unit_test_end ( 'locate' ) end subroutine test_locate !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_insert implicit none character ( len = :), allocatable :: arr (:) integer :: place character ( len = :), allocatable :: newkey integer :: i1 , i2 call unit_test_start ( 'insert' , 'insert value into allocatable array by index\"  ' , opts = share , matched = matched ) if (. not . matched ) return ! make sure sorted in descending order arr = [ character ( len = 20 ) :: '' , 'ZZZ' , 'aaa' , 'b' , 'xxx' ] call sort_shell ( arr , order = 'd' ) newkey = 'NEW' i1 = size ( arr ) call locate ( arr , newkey , place ) ! find where string is or should be call unit_test ( 'insert' , place . lt . 0 , 'should not be located' , place ) if ( place . lt . 1 ) then ! if string was not found insert it call insert ( arr , newkey , abs ( place )) ! not found so insert call locate ( arr , newkey , place ) ! find where string is or should be if ( place . gt . 0 ) then call unit_test ( 'insert' , arr ( place ). eq . 'NEW' , arr ( place ), 'should be \"NEW\"' ) else call unit_test ( 'insert' ,. false ., arr ( place ), 'should be positive for \"NEW\"' ) endif else call unit_test ( 'insert' , place . le . 0 , 'found but should not have been' , place ) endif i2 = size ( arr ) call unit_test ( 'insert' , i1 + 1. eq . i2 , 'array now bigger' , i1 , 'to' , i2 ) call unit_test_end ( 'insert' ) end subroutine test_insert !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_remove use M_sort , only : sort_shell character ( len = :), allocatable :: arr (:) integer :: place integer :: isize call unit_test_start ( 'remove' , 'remove value from allocatable array by index\"  ' , opts = share , matched = matched ) if (. not . matched ) return arr = [ character ( len = 20 ) :: '' , 'ZZZ' , 'Z' , 'aaa' , 'b' , 'x' , 'ab' , 'bb' , 'xxx' ] call sort_shell ( arr , order = 'd' ) ! make sure sorted in descending order isize = size ( arr ) call locate ( arr , 'ab' , place ) ! find where string is or should be call unit_test ( 'remove' , place . gt . 0 , 'found the element to remove' , place ) call remove ( arr , place ) call locate ( arr , 'ab' , place ) ! find where string is or should be call unit_test ( 'remove' , place . lt . 0 , 'did not find the element to remove' , place ) call locate ( arr , 'bb' , place ) ! find where string is or should be call remove ( arr , place ) call unit_test ( 'remove' , isize - 2. eq . size ( arr ), 'shrunk by two' ) call unit_test_end ( 'remove' ) end subroutine test_remove !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_replace use M_sort , only : sort_shell character ( len = :), allocatable :: arr (:) integer :: place1 integer :: isize call unit_test_start ( 'replace' , 'replace value from allocatable array by index\"  ' , opts = share , matched = matched ) if (. not . matched ) return arr = [ character ( len = 20 ) :: '' , 'ZZZ' , 'Z' , 'aaa' , 'b' , 'x' , 'ab' , 'bb' , 'xxx' ] call sort_shell ( arr , order = 'd' ) ! make sure sorted in descending order isize = size ( arr ) call locate ( arr , 'ab' , place1 ) ! find where string is or should be call unit_test ( 'replace' , place1 . gt . 0 , 'location=' , place1 ) call replace ( arr , 'new value for ab' , place1 ) ! add 0+ to avoid gfortran-11 bug call unit_test ( 'replace' , size ( arr ). eq . isize , 'no change in size' , 0 + size ( arr )) if ( place1 . gt . 0. and . place1 . le . isize ) then call unit_test ( 'replace' , arr ( place1 ). eq . 'new value for ab' , arr ( place1 )) else call unit_test ( 'replace' ,. false ., 'bad location' , place1 ) endif call unit_test_end ( 'replace' ) end subroutine test_replace !=================================================================================================================================== end subroutine test_suite_M_list !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !===================================================================================================================================","tags":"","loc":"sourcefile/test_suite_m_list.f90.html"}]}